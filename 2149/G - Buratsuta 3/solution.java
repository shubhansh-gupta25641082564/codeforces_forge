//package com.example.practice.codeforces; import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.ArrayDeque;import java.util.ArrayList;import java.util.Arrays;import java.util.Comparator;import java.util.StringTokenizer; public class Solution {    public static void main(String [] args) throws IOException {        // Use BufferedReader rather than RandomAccessFile; it's much faster        final BufferedReader input = new BufferedReader(new InputStreamReader(System.in));        final PrintWriter out = new PrintWriter(System.out);        // input file name goes above        int Q = Integer.parseInt(input.readLine());        while (Q > 0) {            StringTokenizer st = new StringTokenizer(input.readLine());            final int n = Integer.parseInt(st.nextToken()), q = Integer.parseInt(st.nextToken());            final int[] ns = readArrayInt(n, input);            final int[][] qs = readArray2DInt(q, q, input);            printArray2DInt(calc(n, q, ns, qs), q, out);            Q--;        }        out.close();       // close the output file    }     private static int[][] calc(final int n, final int q, final int[] ns, final int[][] qs) {        final int[][] ns2 = new int[n][], res = new int[q][];        final int[] ps = new int[n], nums = new int[n+1];        for (int i=0;i<n;++i) {            ns2[i] = new int[]{ns[i], i};        }        Arrays.sort(ns2, Comparator.comparingInt(a -> a[0]));        int p = 1;        for (int i=0;i<n;++i) {            if (i > 0 && ns2[i][0] > ns2[i-1][0]) {                p++;            }            ps[ns2[i][1]] = p;            nums[p] = ns2[i][0];        }        final ArrayList<Integer>[] als = new ArrayList[p+1];        for (int i=1;i<=p;++i) {            als[i] = new ArrayList<>();        }        for (int i=0;i<n;++i) {            als[ps[i]].add(i);        }        final SegTree2 segTree = new SegTree2(n, ps, als);        for (int i=0;i<q;++i) {            final int l = qs[i][0] - 1, r = qs[i][1] - 1, tar = (r - l + 1) / 3 + 1;            final int[] kk = segTree.get(1, 0, n-1, l, r);            if (kk[0] >= tar) {                if (kk[3] > 0 && kk[2] >= tar) {                    res[i] = new int[]{Math.min(nums[kk[1]], nums[kk[3]]),                            Math.max(nums[kk[1]], nums[kk[3]])};                } else {                    res[i] = new int[]{nums[kk[1]]};                }            } else {                res[i] = new int[]{-1};            }        }        return res;    }     private static int biSearch(final ArrayList<Integer> al, final int st, final int en) {        int l = 0, r = al.size() - 1;        while (l <= r) {            final int mid = (l + r) >> 1;            if (al.get(mid) >= st) {                r = mid - 1;            } else {                l = mid + 1;            }        }        int pre = l;        l = 0;        r = al.size() - 1;        while (l <= r) {            final int mid = (l + r) >> 1;            if (al.get(mid) > en) {                r = mid - 1;            } else {                l = mid + 1;            }        }        if (r >= pre) {            return r - pre + 1;        }        return 0;    }     static class SegTree2 {        final int[][] vs;        final ArrayList<Integer>[] als;        public SegTree2(final int n, final int[] ns, final ArrayList<Integer>[] als2) {            vs = new int[4][n*4+10];            als = als2;            build(1, 0, n-1, ns);        }         private void build(final int idx, final int l, final int r, final int[] ns) {            if (l == r) {                vs[0][idx] = 1;                vs[1][idx] = ns[l];            } else {                final int mid = (l + r) >> 1, a = idx + idx, b = a + 1;                build(a, l, mid, ns);                build(b, mid+1, r, ns);                final int[] res = merge(get(a, l, mid, l, mid), get(b, mid+1, r, mid+1, r), l, r);                for (int i=0;i<4;++i) {                    vs[i][idx] = res[i];                }            }        }         public int[] get(final int idx, final int l, final int r, final int l2, final int r2) {            if (l == l2 && r == r2) {                return new int[]{vs[0][idx], vs[1][idx], vs[2][idx], vs[3][idx]};            } else {                final int mid = (l + r) >> 1, a = idx + idx, b = a + 1;                if (r2 <= mid) {                    return get(a, l, mid, l2, r2);                } else if (l2 > mid) {                    return get(b, mid+1, r, l2, r2);                } else {                    return merge(get(a, l, mid, l2, mid), get(b, mid+1, r, mid+1, r2), l2, r2);                }            }        }         private int[] merge(final int[] ll, final int[] rr, final int l, final int r) {            final int[] res = new int[]{0, 0, 0, 0};            check(res, ll[0], ll[1], rr, l, r);            if (ll[3] > 0) {                check(res, ll[2], ll[3], rr, l, r);            }            if (rr[1] != ll[1] && rr[1] != ll[3]) {                check(res, rr[0], rr[1], ll, l, r);            }            if (rr[3] > 0 && rr[3] != ll[1] && rr[3] != ll[3]) {                check(res, rr[2], rr[3], ll, l, r);            }            return res;        }         private void check(final int[] result, final int fq, final int idx, final int[] other,                           final int l, final int r) {            int c = fq;            if (idx == other[1]) {                c += other[0];            } else if (idx == other[3]) {                c += other[2];            } else {                c = biSearch(als[idx], l, r);            }            if (result[1] == 0 || result[0] < c) {                result[2] = result[0];                result[3] = result[1];                result[0] = c;                result[1] = idx;            } else if (result[3] == 0 || result[2] < c) {                result[2] = c;                result[3] = idx;            }        }    }     private static void printArray(long[] ns, final PrintWriter out){        for (int i=0;i<ns.length;++i){            out.print(ns[i]);            if (i+1<ns.length)out.print(" ");            else out.println();        }    }     private static void printArrayInt(int[] ns, final PrintWriter out){        for (int i=0;i<ns.length;++i){            out.print(ns[i]);            if (i+1<ns.length)out.print(" ");            else out.println();        }    }     private static void printArrayVertical(long[] ns, final PrintWriter out){        for (long a : ns){            out.println(a);        }    }     private static void printArrayVerticalInt(int[] ns, final PrintWriter out){        for (int a : ns){            out.println(a);        }    }     private static void printArray2D(long[][] ns, final int len, final PrintWriter out){        int cnt = 0;        for (long[] kk : ns){            cnt++;            if (cnt > len)break;            for (int i=0;i<kk.length;++i){                out.print(kk[i]);                if (i+1<kk.length)out.print(" ");                else out.println();            }        }    }     private static void printArray2DInt(int[][] ns, final int len, final PrintWriter out){        int cnt = 0;        for (int[] kk : ns){            cnt++;            if (cnt > len)break;            for (int i=0;i<kk.length;++i){                out.print(kk[i]);                if (i+1<kk.length)out.print(" ");                else out.println();            }        }    }     private static long[] readArray(final int n, final BufferedReader input) throws IOException{        long[] ns = new long[n];        StringTokenizer st = new StringTokenizer(input.readLine());        for (int i=0;i<n;++i){            ns[i] = Long.parseLong(st.nextToken());        }        return ns;    }     private static int[] readArrayInt(final int n, final BufferedReader input) throws IOException{        int[] ns = new int[n];        StringTokenizer st = new StringTokenizer(input.readLine());        for (int i=0;i<n;++i){            ns[i] = Integer.parseInt(st.nextToken());        }        return ns;    }     private static long[] readArrayVertical(final int n, final BufferedReader input) throws IOException{        long[] ns = new long[n];        for (int i=0;i<n;++i){            ns[i] = Long.parseLong(input.readLine());        }        return ns;    }     private static int[] readArrayVerticalInt(final int n, final BufferedReader input) throws IOException{        int[] ns = new int[n];        for (int i=0;i<n;++i){            ns[i] = Integer.parseInt(input.readLine());        }        return ns;    }     private static long[][] readArray2D(final int n, final int len, final BufferedReader input) throws IOException{        long[][] ns = new long[len][];        for (int i=0;i<n;++i){            StringTokenizer st = new StringTokenizer(input.readLine());            ArrayList<Long> al = new ArrayList<>();            while (st.hasMoreTokens()){                al.add(Long.parseLong(st.nextToken()));            }            long[] kk = new long[al.size()];            for (int j=0;j<kk.length;++j){                kk[j] = al.get(j);            }            ns[i] = kk;        }        return ns;    }     private static int[][] readArray2DInt(final int n, final int len, final BufferedReader input) throws IOException{        int[][] ns = new int[len][];        for (int i=0;i<n;++i){            StringTokenizer st = new StringTokenizer(input.readLine());            ArrayList<Integer> al = new ArrayList<>();            while (st.hasMoreTokens()){                al.add(Integer.parseInt(st.nextToken()));            }            int[] kk = new int[al.size()];            for (int j=0;j<kk.length;++j){                kk[j] = al.get(j);            }            ns[i] = kk;        }        return ns;    }     private static long[][] readArray2DWithIdx(final int n, final int m, final BufferedReader input) throws IOException{        long[][] ns = new long[n][m+1];        for (int i=0;i<n;++i){            StringTokenizer st = new StringTokenizer(input.readLine());            for (int j=0;j<m;++j){                ns[i][j] = Long.parseLong(st.nextToken());            }            ns[i][m] = i;        }        return ns;    }     private static int[][] readArray2DIntWithIdx(final int n, final int m, final BufferedReader input) throws IOException{        int[][] ns = new int[n][m+1];        for (int i=0;i<n;++i){            StringTokenizer st = new StringTokenizer(input.readLine());            for (int j=0;j<m;++j){                ns[i][j] = Integer.parseInt(st.nextToken());            }            ns[i][m] = i;        }        return ns;    }     private static String[] readArrayString(final int n, final BufferedReader input) throws IOException{        String[] res = new String[n];        for (int i=0;i<n;++i){            res[i] = input.readLine();        }        return res;    }     private static int GCD(int x, int y){        if (x > y)return GCD(y, x);        if (x==0)return y;        return GCD(y%x, x);    }     private static long GCD(long x, long y){        if (x > y)return GCD(y, x);        if (x==0)return y;        return GCD(y%x, x);    }     private static ArrayList<int[]>[] convertToGraphUnDirectWithWeight(final int n, final int[][] es){        ArrayList<int[]>[] als = new ArrayList[n+1];        for (int i=0;i<=n;++i){            als[i] = new ArrayList<>();        }        for (int[] e : es){            als[e[0]].add(Arrays.copyOfRange(e, 1, e.length));            final int[] kk = Arrays.copyOfRange(e, 1, e.length);            kk[0] = e[0];            als[e[1]].add(kk);        }        return als;    }     private static ArrayList<int[]>[] convertToGraphDirectWithWeight(final int n, final int[][] es){        ArrayList<int[]>[] als = new ArrayList[n+1];        for (int i=0;i<=n;++i){            als[i] = new ArrayList<>();        }        for (int[] e : es){            als[e[0]].add(Arrays.copyOfRange(e, 1, e.length));        }        return als;    }     private static ArrayList<int[]>[] convertToGraphUnDirect(final int n, final int[][] es){        ArrayList<int[]>[] als = new ArrayList[n+1];        for (int i=0;i<=n;++i){            als[i] = new ArrayList<>();        }        int p = 0;        for (int[] e : es){            als[e[0]].add(new int[]{e[1], p});            als[e[1]].add(new int[]{e[0], p++});        }        return als;    }     private static ArrayList<int[]>[] convertToGraphDirect(final int n, final int[][] es){        ArrayList<int[]>[] als = new ArrayList[n+1];        for (int i=0;i<=n;++i){            als[i] = new ArrayList<>();        }        int p = 0;        for (int[] e : es){            als[e[0]].add(new int[]{e[1], p++});        }        return als;    }     private static int find(final int[] rd, int idx){        while (idx != rd[idx]){            rd[idx] = rd[rd[idx]];            idx = rd[idx];        }        return idx;    }     private static long pow(final long a, final long x, final int MODE){        if (x==0)return 1L;        long res = pow(a, x>>1, MODE);        res = res * res % MODE;        if ((x&1) == 1){            res = res * a % MODE;        }        return res;    }     private static long[][] getCombArray(final int n, final int k, final int MODE) {        final long[][] res = new long[n+1][k+1];        res[0][0] = 1L;        for (int i=1;i<=n;++i) {            res[i][0] = 1L;            if (i <= k) {                res[i][i] = 1L;            }            for (int j=1;j<i && j<=k;++j) {                res[i][j] = (res[i-1][j] + res[i-1][j-1]) % MODE;            }        }        return res;    }     private static long multiInv(final int n, final int MODE) {        return pow(n, MODE - 2, MODE);    }     private static long[] getFac(final int n, final int MODE) {        final long[] res = new long[n+1];        res[0] = 1;        for (int i=1;i<=n;++i) {            res[i] = i * res[i-1] % MODE;        }        return res;    }     private static long[] getFacInv(final int n, final int MODE) {        final long[] res = new long[n+1];        res[1] = 1;        for (int i=2;i<=n;++i) {            res[i] = (MODE - MODE / i) * res[MODE % i] % MODE;        }        for (int i=2;i<=n;++i) {            res[i] = res[i] * res[i-1] % MODE;        }        return res;    }     private static long comb(final int n, final int c, final long[] fc,                             final long[] inv, final int MODE) {        if (c == 0 || c == n)return 1L;        return fc[n] * inv[c] % MODE * inv[n-c] % MODE;    }     private static int[] getMobius(final int n) {        final int[] res = new int[n+1], pm = new int[n+1], sta = new int[n+1];        int p = 0;        res[1] = 1;        for (int i=2;i<=n;++i) {            if (pm[i] == 0){                pm[i] = i;                sta[p++] = i;                res[i] = -1;            }            for (int j=0;j<p;++j) {                final int num = sta[j] * i;                if (sta[j] > pm[i] || num > n) {                    break;                }                pm[num] = sta[j];                if (pm[i] == sta[j]) {                    res[num] = 0;                } else {                    res[num] = -res[i];                }            }        }        return res;    }     private static int[][] getKMP(final char[] cc) {        final int n = cc.length;        final int[][] res = new int[2][n];        res[0][0] = res[1][0] = -1;        int cur = -1;        for (int i=1;i<n;++i) {            ++cur;            if (cc[cur] != cc[i]) {                res[0][i] = cur;                while (cur >= 0 && cc[cur] != cc[i]) {                    cur = res[0][cur];                }            } else {                res[0][i] = res[0][cur];            }            res[1][i] = cur;        }        return res;    }     private static boolean[] getPrimeArray(final int n) {        boolean[] ps = new boolean[n+1];        for (int i=2;i*i<=n;++i){            if (!ps[i]) {                for (int j = i * i; j <= n; j += i) {                    ps[j] = true;                }            }        }        ps[0] = ps[1] = true;        return ps;    }     private static ArrayList<Integer> getPrimes(final int n, final boolean[] ps) {        final ArrayList<Integer> prime = new ArrayList<>();        for (int i=2;i<=n;++i){            if (!ps[i]){                prime.add(i);            }        }        return prime;    }     private static ArrayList<int[]> findAllMatch(final char[] cc, final char[] pt) {        final int[][] kmp = getKMP(pt);        final int n = cc.length, m = pt.length;        final ArrayList<int[]> res = new ArrayList<>();        for (int i=0,j=0;i<=n-(m-j);) {            if (cc[i] == pt[j]) {                i++;                j++;                if (j == m) {                    res.add(new int[]{i-m, i});                    if (kmp[1][m-1] < 0) {                        j = 0;                    }else {                        j = kmp[1][m-1] + 1;                    }                }            } else if (kmp[0][j] < 0) {                i++;                j = 0;            } else {                j = kmp[0][j];            }        }        return res;    }     private static int exGCD(final int a, final int b, final long[] x, final long[] y) {        if (b == 0){            x[0] = 1;            y[0] = 0;            return a;        }        final int d = exGCD(b, a % b, x, y);        long tem = x[0];        x[0] = y[0];        y[0] = tem - a / b * y[0];        return d;    }     private static int findRoot(ArrayList<Integer>[] als) {        if (als.length <= 10)return 1;        int res = 0;        ArrayDeque<Integer> ll = new ArrayDeque<>();        int[] rd = new int[als.length];        for (int i=1;i<als.length;++i){            if (als[i].size()==1){                ll.add(i);            }            rd[i] = als[i].size();        }        while (!ll.isEmpty()){            int k = ll.poll();            res = k;            for (int a : als[k]){                rd[a]--;                if (rd[a]==1){                    ll.add(a);                }            }        }        return res;    }     private static int findRoot2(ArrayList<int[]>[] als) {        if (als.length <= 10)return 1;        int res = 0;        ArrayDeque<Integer> ll = new ArrayDeque<>();        int[] rd = new int[als.length];        for (int i=1;i<als.length;++i){            if (als[i].size()==1){                ll.add(i);            }            rd[i] = als[i].size();        }        while (!ll.isEmpty()){            int k = ll.poll();            res = k;            for (int[] kk : als[k]){                rd[kk[0]]--;                if (rd[kk[0]]==1){                    ll.add(kk[0]);                }            }        }        return res;    }     static class SegTree{        long sum;        long diff;        int st;        int en;        int mid;        int val1;        int val2;        SegTree left;        SegTree right;        public SegTree(int l, int r, int d){            sum = diff = 0;            st = l;            en = r;            mid = (st + en) >> 1;            val1 = val2 = d;            if (st<en){                left = new SegTree(st, mid, d);                right = new SegTree(mid+1, en, d);            }else {                left = right = null;            }        }         public SegTree(int l, int r, int[] ns){            sum = diff = 0;            st = l;            en = r;            mid = (st + en) >> 1;            if (st==en){                val1 = val2 = ns[st];            }else {                left = new SegTree(l, mid, ns);                right = new SegTree(mid+1, r, ns);                val1 = Math.min(left.val1, right.val1);                val2 = Math.max(left.val2, right.val2);            }        }         void update(int idx, int v){            if (st==en){                val1 = val2 = v;            }else {                pushDown();                if (idx <= mid){                    left.update(idx, v);                }else {                    right.update(idx, v);                }                val1 = Math.min(left.val1, right.val1);                val2 = Math.max(left.val2, right.val2);            }        }         int getMin(int l, int r){            if (st==en || (l==st && r==en))return val1;            pushDown();            if (r<=mid){                return left.getMin(l, r);            }            if (l>mid){                return right.getMin(l, r);            }            return Math.min(left.getMin(l, mid), right.getMin(mid+1, r));        }         int getMax(int l, int r){            if (st==en || (l==st && r==en))return val2;            pushDown();            if (r<=mid){                return left.getMax(l, r);            }            if (l>mid){                return right.getMax(l, r);            }            return Math.max(left.getMax(l, mid), right.getMax(mid+1, r));        }         long rangeAdd(final int l, final int r, long d){            long res;            if (st==l && en==r){                res = (en-st+1) * d;                sum += res;                val1 += d;                val2 += d;                if (st < en) {                    this.diff += d;                }            }else {                pushDown();                if (r<=mid){                    res = left.rangeAdd(l, r, d);                    sum += res;                }else if (l>mid){                    res = right.rangeAdd(l, r, d);                    sum += res;                }else {                    res = left.rangeAdd(l, mid, d);                    res += right.rangeAdd(mid+1, r, d);                    sum += res;                }                val1 = Math.min(left.val1, right.val1);                val2 = Math.max(left.val2, right.val2);            }            return res;        }         long querySum(final int l, final int r){            pushDown();            long res;            if (st==l && en==r){                res = sum;            }else if (r<=mid){                res = left.querySum(l, r);            }else if (l>mid){                res = right.querySum(l, r);            }else {                res = left.querySum(l, mid);                res += right.querySum(mid+1, r);            }            return res;        }         private void pushDown(){            if (diff!=0 && st<en){                left.loadDiff(this.diff);                right.loadDiff(this.diff);                this.diff = 0;            }        }         private void loadDiff(final long d){            sum += d * (en-st+1);            val1 += d;            val2 += d;            if (st < en){                this.diff += d;            }        }    }     static class SparseTable{        int[][] minTable;        int[][] maxTable;        int[] log2;        int n;        public SparseTable(final int[] ns){            n = ns.length;            int m = 0, pre = 0;            while (1<<m < n){                m++;            }            m++;            minTable = new int[n][m];            maxTable = new int[n][m];            log2 = new int[n+1];            for (int i=0;i<n;++i){                minTable[i][0] = ns[i];                maxTable[i][0] = ns[i];                if ((1<<(pre+1)) == i+1){                    pre++;                }                log2[i+1] = pre;            }            for (int i=1;i<m;++i){                for (int j=0;j<n;++j){                    int r = Math.min(n-1, j+(1<<i)-1);                    if (r-(1<<(i-1))+1 <= j){                        minTable[j][i] = minTable[j][i-1];                        maxTable[j][i] = maxTable[j][i-1];                    }else {                        minTable[j][i] = Math.min(minTable[j][i-1], minTable[r-(1<<(i-1))+1][i-1]);                        maxTable[j][i] = Math.max(maxTable[j][i-1], maxTable[r-(1<<(i-1))+1][i-1]);                    }                }            }        }         int getMin(final int l, final int r){            int d = log2[r-l+1];            return Math.min(minTable[l][d], minTable[r-(1<<d)+1][d]);        }         int getMax(final int l, final int r){            int d = log2[r-l+1];            return Math.max(maxTable[l][d], maxTable[r-(1<<d)+1][d]);        }    }     static class BIT{        long[] ns;        public BIT(int n){            ns = new long[n];        }        void add(int idx, int v){            for (int i=idx; i<ns.length; i += -i & i){                ns[i] += v;            }        }        long get(int idx){            long res = 0;            for (int i=idx; i>0; i -= -i & i){                res += ns[i];            }            return res;        }        int getFloor(long v) {            int res = 0;            for (int i=Integer.highestOneBit(ns.length);i>0;i>>=1){                if (res+i < ns.length && ns[res+i] <= v){                    res += i;                    v -= ns[res];                }            }            return res;        }    }     static class NTT{        final int g;        final int mod;        final int M = 1000010;        private int[] rev;        public NTT(int a, int b){            mod = a;            g = b;            rev = new int[M+1];        }        private long pow(long a, int x){            long res = 1, a2 = a;            while (x > 0){                if ((x&1) == 1){                    res = res * a2 % mod;                }                x = x>>1;                a2 = a2 * a2 % mod;            }            return res;        }        private void ntt(long[] ns, final int len, final int type){            for (int i=0;i<len;++i){                if (i < rev[i]){                    long temp = ns[i];                    ns[i] = ns[rev[i]];                    ns[rev[i]] = temp;                }            }            for (int i=1;i<len;i=i<<1){                final long gn;                if (type != -1){                    gn = pow(g, (mod-1)/(i<<1));                }else {                    gn = pow(pow(g, (mod-1)/(i<<1)), mod-2);                }                for (int j=0;j<len;j+=(i<<1)){                    long gi = 1;                    for (int k=0;k<i;++k){                        final long x = ns[j+k], y = gi * ns[i+j+k] % mod;                        ns[j+k] = (x+y) < mod ? x+y : x+y-mod;                        ns[i+j+k] = x-y >= 0 ? x-y : x-y+mod;                        gi = gi * gn % mod;                    }                }            }            if (type == -1){                final long inv = pow(len, mod-2);                for (int i=0;i<len;++i){                    ns[i] = ns[i] * inv % mod;                }            }        }         public long[] multi(final int[] as){            long l1 = extend(as);            int len = 1, L = 0;            while (len <= l1+l1){                len = len << 1;                L++;            }            for (int i=0;i<len;++i){                rev[i] = (rev[i>>1] >> 1) | ((i & 1) << (L-1));            }            long[] xx = new long[len];            for (int i=0;i<as.length;++i){                xx[i] = as[i];            }            ntt(xx, len, 1);            for (int i=0;i<len;++i){                xx[i] = xx[i] * xx[i] % mod;            }            ntt(xx, len ,-1);            return xx;        }         public long[] multi(final int[] as, final int[] bs){            long l1 = extend(as), l2 = extend(bs);            int len = 1, L = 0;            while (len <= l1+l2){                len = len << 1;                L++;            }            for (int i=0;i<len;++i){                rev[i] = (rev[i>>1] >> 1) | ((i & 1) << (L-1));            }            long[] xx = new long[len], yy = new long[len];            for (int i=0;i<as.length;++i){                xx[i] = as[i];            }            for (int i=0;i<bs.length;++i){                yy[i] = bs[i];            }            ntt(xx, len, 1);            ntt(yy, len, 1);            for (int i=0;i<len;++i){                xx[i] = xx[i] * yy[i] % mod;            }            ntt(xx, len ,-1);            return xx;        }         private long extend(final int[] ns){            /*int len;            if (ns.length - (ns.length & (0-ns.length)) == 0){                len = ns.length;            }else {                len = 1;                while (len < ns.length){                    len = len << 1;                }            }            return len;*/            return ns.length;        }    }}