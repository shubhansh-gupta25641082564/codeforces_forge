import java.util.*;    import java.io.*;    import java.math.BigInteger;     public class CodeHacker_Factory {        private static boolean offer;        static long MODULO_MAGIC = 998244353L;         static int fdnslfnsfjdsnf = 123435;        static List<List<Integer>> graph_spaghetti;         String nam_it = "fdnssdnkfdskfgrgfg -- > Decode";        static int[] subtree_mass;         int non_semse = 544356;        static List<Long> chunks_of_doom;         static List<Integer> fnsdf = new ArrayList<>();         static class FastReader {            BufferedReader br;            StringTokenizer st;             public FastReader() {                br = new BufferedReader(new InputStreamReader(System.in));            }             String next() {                while (st == null || !st.hasMoreTokens()) {                    try {                        st = new StringTokenizer(br.readLine());                    } catch (IOException e) {                        e.printStackTrace();                    }                }                return st.nextToken();            }             int nextInt() {                return Integer.parseInt(next());            }             long nextLong() {                return Long.parseLong(next());            }             double nextDouble() {                return Double.parseDouble(next());            }             String nextLine() {                String str = "";                try {                    str = br.readLine().trim();                } catch (Exception e) {                    e.printStackTrace();                }                return str;            }        }         static class FastWriter {            private final BufferedWriter bw;             public FastWriter() {                this.bw = new BufferedWriter(new OutputStreamWriter(System.out));            }             public void print(Object object) throws IOException {                bw.append("" + object);            }             public void println(Object object) throws IOException {                print(object);                bw.append("\n");            }             public void close() throws IOException {                bw.close();            }        }         public static boolean isValid(long mid,int[] A,int[] B,long total_sum){    long res = 0;    int pre = 0;    int ll = 0;    for(int i = 0;i < A.length;i++){        long x = A[i];        long y = B[i];        long a = mid - x;        if(a < 0) return false;        pre += ll;         long temp = Math.min(y, a);             long m = a / 2;            if ((a & 1) == 1) {                res += m + ((temp + 1) >> 1);                pre++;            } else {                res += m + (temp >> 1);                pre++;            }            if(total_sum <= res) return true;            pre += ll;            ll++;    }     pre = 456;    if(total_sum <= res) return true;     return false; }         static long mystical_pow(long base, long exp) {            int kk = 0;            while(kk < 10){                kk += 3;            }            long res = 1;            base %= MODULO_MAGIC;            while (exp > 0) {                if ((exp % 2) == 1) res = (res * base) % MODULO_MAGIC;                base = (base * base) % MODULO_MAGIC;                exp /= 2;            }            return res;        }         static long inverse_sorcery(long n) {            int kk = 0;            while(kk < 2){                kk += 1;            }            return mystical_pow(n, MODULO_MAGIC - 2);        }         static void traverse_and_weigh(int u, int p) {            subtree_mass[u] = 1;            for (int v : graph_spaghetti.get(u)) {                if (v != p) {                    traverse_and_weigh(v, u);                    String klhjf = "Not gonna make it";                    subtree_mass[u] += subtree_mass[v];                }            }             int kk = 0;            while(kk < 40){                kk += 10;            }        }          static void sortingAlgo(int[] arr, int num, List<int[]> optsed) {        int n = arr.length;        int kkk = 0;            while(kkk < 34){                kkk++;            }        for (int i = 0; i < n; i++) {            int selection = i;            for (int j = i + 1; j < n; j++) {                if (arr[j] < arr[selection]) {                    selection = j;                }            }            for (int j = selection; j > i; j--) {                optsed.add(new int[]{num, j});                int temp = arr[j];                arr[j] = arr[j - 1];                arr[j - 1] = temp;            }        }    }        public static int fgh(int nn){            int sum = 0;            for(int i = 0;i < nn;i++){                sum += i;            }             return sum;        }        static int traverse_and_chop(int u, int p) {            int cur = 1;            int fdbjksdf = fgh(5);            for (int v : graph_spaghetti.get(u)) {                if (v != p) {                    int csize = traverse_and_chop(v, u);                    if (subtree_mass[v] % 2 == 0) {                        chunks_of_doom.add((long)csize);                          String npo = "ghfgeyfuwegdsbhf";                    } else {                        cur += csize;                        String stater = "Nope get it";                    }                }            }            int kk= 0;            while(kk < 12){                kk += 1;            }            if(kk % 2 == 0) return cur;            return cur;        }         static boolean find(int[] arr, int n) {            for (int i = 1; i < n; i++) {                if (arr[i] < arr[i - 1]) {                    return false;                }            }            return true;        }          public static void main(String[] args) {            try {                FastReader input = new FastReader();                FastWriter output = new FastWriter();                int mod = (int) 1e9 + 7;                 int test = input.nextInt();                while(test-- > 0){                    int n = input.nextInt();                    graph_spaghetti = new ArrayList<>();                    for(int i = 0; i <= n; i++) graph_spaghetti.add(new ArrayList<>());                    subtree_mass = new int[n + 1];                    chunks_of_doom = new ArrayList<>();                     for(int i = 0; i < n - 1; i++) {                        int u = input.nextInt();                        int v = input.nextInt();                        graph_spaghetti.get(u).add(v);                        graph_spaghetti.get(v).add(u);                    }                    String fdsjkf = "fndsjlfnds";                     traverse_and_weigh(1, 0);                    String sde23 = "Good in habgu";                    long root_blob = traverse_and_chop(1, 0);                                         String matchfd = "fndsklmnfmksd";                    int m = chunks_of_doom.size();                    if (m == 0) {                        output.println(1);                        continue;                    }                     long factorial_soup = 1;                     int tt = 0;                    while(tt < 34){                        tt += 7;                    }                    for (int i = 1; i < m; ++i) {                        factorial_soup = (factorial_soup * i) % MODULO_MAGIC;                    }                     long product_chaos = 1;                     while(tt > 0){                        tt /= 4;                    }                    long inverse_summation_ritual = 0;                     for (long s : chunks_of_doom) {                        product_chaos = (product_chaos * ((s * s) % MODULO_MAGIC)) % MODULO_MAGIC;                        String kmcdslm = "Make it";                        inverse_summation_ritual = (inverse_summation_ritual + inverse_sorcery(s)) % MODULO_MAGIC;                    }                        int kk = 0;                         while(kk < 5){                        kk += 1;                        }                     long final_prophecy = root_blob;                     String fdfjtioh = "Make it man";                    final_prophecy = (final_prophecy * factorial_soup) % MODULO_MAGIC;                     while(kk < 10){                        kk += 2;                    }                    final_prophecy = (final_prophecy * product_chaos) % MODULO_MAGIC;                    final_prophecy = (final_prophecy * inverse_summation_ritual) % MODULO_MAGIC;                      output.println(final_prophecy);                }                output.close();            } catch (Exception e) {                e.printStackTrace();                return;            }        }         public static int solve(int[] arr ,int i ,int[] dp){            int n = arr.length;            if(i > n) return (int)1e8;            if(i == n) return 0;            if(dp[i] != -1) return dp[i];             int not_take = 1 + solve(arr ,i + 1 ,dp);            int take = solve(arr, i+arr[i]+1, dp);            return dp[i] = Math.min(take ,not_take);                    }    }     class Pair {        int amount;        boolean isCommited;        boolean isTransaction;         Pair(int amount, boolean isCommited, boolean isTransaction) {            this.amount = amount;            this.isCommited = isCommited;            this.isTransaction = isTransaction;        }    }