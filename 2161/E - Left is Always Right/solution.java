import java.io.*;import java.math.BigInteger;import java.util.*; public class E {	FastScanner in;	PrintWriter out;	boolean systemIO = true; 	int mod = 998244353; 	public int sum(int x, int y) {		if (x + y >= mod) {			return x + y - mod;		}		return x + y;	} 	public int diff(int x, int y) {		if (x >= y) {			return x - y;		}		return x - y + mod;	} 	public int mult(int x, int y) {		return (int) (x * 1L * y % mod);	} 	public int pow(int x, long p) {		int ans = 1;		while (p > 0) {			if ((p & 1) == 1) {				ans = mult(ans, x);			}			x = mult(x, x);			p >>= 1;		}		return ans;	} 	public int inv(int x) {		return pow(x, mod - 2);	} 	public int div(int x, int y) {		return mult(x, inv(y));	} 	public class DSU {		int[] sz;		int[] p; 		public DSU(int n) {			sz = new int[n];			p = new int[n];			for (int i = 0; i < p.length; i++) {				p[i] = i;				sz[i] = 1;			}		} 		public int get(int x) {			if (x == p[x]) {				return x;			}			int par = get(p[x]);			p[x] = par;			return par;		} 		public boolean unite(int a, int b) {			int pa = get(a);			int pb = get(b);			if (pa == pb) {				return false;			}			if (sz[pa] < sz[pb]) {				p[pa] = pb;				sz[pb] += sz[pa];			} else {				p[pb] = pa;				sz[pa] += sz[pb];			}			return true;		}	} 	public class SegmentTreeAdd {		int pow;		long[] max;		long[] delta;		boolean[] flag; 		public SegmentTreeAdd(long[] a) {			pow = 1;			while (pow < a.length) {				pow *= 2;			}			flag = new boolean[2 * pow];			max = new long[2 * pow];			delta = new long[2 * pow];			for (int i = 0; i < max.length; i++) {				max[i] = Long.MIN_VALUE / 2;			}			for (int i = 0; i < a.length; i++) {				max[pow + i] = a[i];			}			for (int i = pow - 1; i > 0; i--) {				max[i] = f(max[2 * i], max[2 * i + 1]);			}		} 		public long get(int v, int tl, int tr, int l, int r) {			push(v, tl, tr);			if (l > r) {				return Long.MIN_VALUE / 2;			}			if (l == tl && r == tr) {				return max[v];			}			int tm = (tl + tr) / 2;			return f(get(2 * v, tl, tm, l, Math.min(r, tm)), get(2 * v + 1, tm + 1, tr, Math.max(l, tm + 1), r));		} 		public void set(int v, int tl, int tr, int l, int r, long x) {			push(v, tl, tr);			if (l > tr || r < tl) {				return;			}			if (l <= tl && r >= tr) {				delta[v] += x;				flag[v] = true;				push(v, tl, tr);				return;			}			int tm = (tl + tr) / 2;			set(2 * v, tl, tm, l, r, x);			set(2 * v + 1, tm + 1, tr, l, r, x);			max[v] = f(max[2 * v], max[2 * v + 1]);		} 		public void push(int v, int tl, int tr) {			if (flag[v]) {				if (v < pow) {					flag[2 * v] = true;					flag[2 * v + 1] = true;					delta[2 * v] += delta[v];					delta[2 * v + 1] += delta[v];				}				flag[v] = false;				max[v] += delta[v];				delta[v] = 0;			}		} 		public long f(long a, long b) {			return Math.max(a, b);		}	} 	public class SegmentTreeSet {		int pow;		int[] sum;		int[] delta;		boolean[] flag; 		public SegmentTreeSet(int[] a) {			pow = 1;			while (pow < a.length) {				pow *= 2;			}			flag = new boolean[2 * pow];			sum = new int[2 * pow];			delta = new int[2 * pow];			for (int i = 0; i < a.length; i++) {				sum[pow + i] = a[i];			}			for (int i = pow - 1; i > 0; i--) {				sum[i] = f(sum[2 * i], sum[2 * i + 1]);			}		} 		public int get(int v, int tl, int tr, int l, int r) {			push(v, tl, tr);			if (l > r) {				return 0;			}			if (l == tl && r == tr) {				return sum[v];			}			int tm = (tl + tr) / 2;			return f(get(2 * v, tl, tm, l, Math.min(r, tm)), get(2 * v + 1, tm + 1, tr, Math.max(l, tm + 1), r));		} 		public void set(int v, int tl, int tr, int l, int r, int x) {			push(v, tl, tr);			if (l > tr || r < tl) {				return;			}			if (l <= tl && r >= tr) {				delta[v] = x;				flag[v] = true;				push(v, tl, tr);				return;			}			int tm = (tl + tr) / 2;			set(2 * v, tl, tm, l, r, x);			set(2 * v + 1, tm + 1, tr, l, r, x);			sum[v] = f(sum[2 * v], sum[2 * v + 1]);		} 		public void push(int v, int tl, int tr) {			if (flag[v]) {				if (v < pow) {					flag[2 * v] = true;					flag[2 * v + 1] = true;					delta[2 * v] = delta[v];					delta[2 * v + 1] = delta[v];				}				flag[v] = false;				sum[v] = delta[v] * (tr - tl + 1);			}		} 		public int f(int a, int b) {			return a + b;		}	} 	public class Pair implements Comparable<Pair> {		int x;		int y; 		public Pair(int x, int y) {			this.x = x;			this.y = y;		} 		public Pair clone() {			return new Pair(x, y);		} 		public String toString() {			return x + " " + y;		} 		@Override		public int compareTo(Pair o) {			if (x > o.x) {				return 1;			}			if (x < o.x) {				return -1;			}			if (y > o.y) {				return 1;			}			if (y < o.y) {				return -1;			}			return 0;		}	} 	Random random = new Random(); 	public void shuffle(Pair[] a) {		for (int i = 0; i < a.length; i++) {			int x = random.nextInt(i + 1);			Pair t = a[x];			a[x] = a[i];			a[i] = t;		}	} 	public void sort(int[][] a) {		for (int i = 0; i < a.length; i++) {			Arrays.sort(a[i]);		}	} 	public void add(Map<Long, Integer> map, long l) {		if (map.containsKey(l)) {			map.put(l, map.get(l) + 1);		} else {			map.put(l, 1);		}	} 	public void remove(Map<Integer, Integer> map, Integer s) {		if (map.get(s) > 1) {			map.put(s, map.get(s) - 1);		} else {			map.remove(s);		}	} 	long max = Long.MAX_VALUE / 2;	double eps = 1e-10; 	public int signum(double x) {		if (x > eps) {			return 1;		}		if (x < -eps) {			return -1;		}		return 0;	} 	public long abs(long x) {		return x < 0 ? -x : x;	} 	public long min(long x, long y) {		return x < y ? x : y;	} 	public long max(long x, long y) {		return x > y ? x : y;	} 	public long gcd(long x, long y) {		while (y > 0) {			long c = y;			y = x % y;			x = c;		}		return x;	}   	public class Rect {		long x1;		long x2;		long y1;		long y2;		int number; 		public Rect(long x1, long x2, long y1, long y2, int number) {			this.x1 = x1;			this.x2 = x2;			this.y1 = y1;			this.y2 = y2;			this.number = number;		}	} 	public static class Fenvik {		int[] t; 		public Fenvik(int n) {			t = new int[n];		} 		public void add(int x, int delta) {			for (int i = x; i < t.length; i = (i | (i + 1))) {				t[i] += delta;			}		} 		private int sum(int r) {			int ans = 0;			int x = r;			while (x >= 0) {				ans += t[x];				x = (x & (x + 1)) - 1;			}			return ans;		} 		public int sum(int l, int r) {			return sum(r) - sum(l - 1);		}	} 	public class SegmentTreeMaxSum {		int pow;		int[] sum;		int[] maxPrefSum;		int[] maxSufSum;		int[] maxSum; 		public SegmentTreeMaxSum(int[] a) {			pow = 1;			while (pow < a.length) {				pow *= 2;			}			sum = new int[2 * pow];			maxPrefSum = new int[2 * pow];			maxSum = new int[2 * pow];			maxSufSum = new int[2 * pow];			for (int i = 0; i < a.length; i++) {				sum[pow + i] = a[i];				maxSum[pow + i] = Math.max(a[i], 0);				maxPrefSum[pow + i] = maxSum[pow + i];				maxSufSum[pow + i] = maxSum[pow + i];			}			for (int i = pow - 1; i > 0; i--) {				update(i);			}		} 		public int[] get(int v, int tl, int tr, int l, int r) {			if (r <= tl || l >= tr) {				int[] ans = { 0, 0, 0, 0 };				return ans;			}			if (l <= tl && r >= tr) {				int[] ans = { maxPrefSum[v], maxSum[v], maxSufSum[v], sum[v] };				return ans;			}			int tm = (tl + tr) / 2;			int[] left = get(2 * v, tl, tm, l, r);			int[] right = get(2 * v + 1, tm, tr, l, r);			int[] ans = { Math.max(left[0], right[0] + left[3]),					Math.max(left[1], Math.max(right[1], left[2] + right[0])), Math.max(right[2], left[2] + right[3]),					left[3] + right[3] };			return ans;		} 		public void set(int v, int tl, int tr, int x, int value) {			if (v >= pow) {				sum[v] = value;				maxSum[v] = Math.max(value, 0);				maxPrefSum[v] = maxSum[v];				maxSufSum[v] = maxSum[v];				return;			}			int tm = (tl + tr) / 2;			if (x < tm) {				set(2 * v, tl, tm, x, value);			} else {				set(2 * v + 1, tm, tr, x, value);			}			update(v);		} 		public void update(int i) {			sum[i] = f(sum[2 * i], sum[2 * i + 1]);			maxSum[i] = Math.max(maxSum[2 * i], Math.max(maxSum[2 * i + 1], maxSufSum[2 * i] + maxPrefSum[2 * i + 1]));			maxPrefSum[i] = Math.max(maxPrefSum[2 * i], maxPrefSum[2 * i + 1] + sum[2 * i]);			maxSufSum[i] = Math.max(maxSufSum[2 * i + 1], maxSufSum[2 * i] + sum[2 * i + 1]);		} 		public int f(int a, int b) {			return a + b;		}	} 	public class Point implements Comparable<Point> {		double x;		double y; 		public Point() {			x = 0;			y = 0;		} 		public Point(double x, double y) {			this.x = x;			this.y = y;		} 		public String toString() {			return x + " " + y;		} 		public boolean equals(Point p) {			return x == p.x && y == p.y;		} 		public double dist2() {			return x * x + y * y;		} 		public Point add(Point v) {			return new Point(x + v.x, y + v.y);		} 		@Override		public int compareTo(Point o) {			int z = signum(x + y - o.x - o.y);			if (z != 0) {				return z;			}			return signum(x - o.x) != 0 ? signum(x - o.x) : signum(y - o.y);		}	} 	public class Circle implements Comparable<Circle> {		Point p;		int r; 		public Circle(Point p, int r) {			this.p = p;			this.r = r;		} 		public Point angle() {			double z = r / sq2;			z -= z % 1e-5;			return new Point(p.x - z, p.y - z);		} 		public boolean inside(Point p) {			return hypot2(p.x - this.p.x, p.y - this.p.y) <= sq(r);		} 		@Override		public int compareTo(Circle o) {			Point a = angle();			Point oa = o.angle();			int z = signum(a.x + a.y - oa.x - oa.y);			if (z != 0) {				return z;			}			return signum(a.y - oa.y);		} 	} 	public class Fraction implements Comparable<Fraction> {		long x;		long y; 		public Fraction(long x, long y, boolean needNorm) {			this.x = x;			this.y = y;			if (y < 0) {				this.x *= -1;				this.y *= -1;			}			if (needNorm) {				long gcd = gcd(this.x, this.y);				this.x /= gcd;				this.y /= gcd;			}		} 		public Fraction clone() {			return new Fraction(x, y, false);		} 		public String toString() {			return x + "/" + y;		} 		@Override		public int compareTo(Fraction o) {			long res = x * o.y - y * o.x;			if (res > 0) {				return 1;			}			if (res < 0) {				return -1;			}			return 0;		}	} 	public double sq(double x) {		return x * x;	} 	public long sq(long x) {		return x * x;	} 	public double hypot2(double x, double y) {		return sq(x) + sq(y);	} 	public long hypot2(long x, long y) {		return sq(x) + sq(y);	} 	public boolean kuhn(int v, int[][] edge, boolean[] used, int[] mt) {		used[v] = true;		for (int u : edge[v]) {			if (mt[u] < 0 || (!used[mt[u]] && kuhn(mt[u], edge, used, mt))) {				mt[u] = v;				return true;			}		}		return false;	} 	public int matching(int[][] edge) {		int n = edge.length;		int[] mt = new int[n];		Arrays.fill(mt, -1);		boolean[] used = new boolean[n];		int ans = 0;		for (int i = 0; i < n; i++) {			if (!used[i] && kuhn(i, edge, used, mt)) {				Arrays.fill(used, false);				ans++;			}		}		return ans;	} 	double sq2 = Math.sqrt(2); 	int small = 20; 	public class MyStack {		int[] st;		int sz; 		public MyStack(int n) {			this.st = new int[n];			sz = 0;		} 		public boolean isEmpty() {			return sz == 0;		} 		public int peek() {			return st[sz - 1];		} 		public int pop() {			sz--;			return st[sz];		} 		public void clear() {			sz = 0;		} 		public void add(int x) {			st[sz++] = x;		} 		public int get(int x) {			return st[x];		}	} 	public int[][] readGraph(int n, int m) {		int[][] to = new int[n][];		int[] sz = new int[n];		int[] x = new int[m];		int[] y = new int[m];		for (int i = 0; i < m; i++) {			x[i] = in.nextInt() - 1;			y[i] = in.nextInt() - 1;			sz[x[i]]++;			sz[y[i]]++;		}		for (int i = 0; i < to.length; i++) {			to[i] = new int[sz[i]];			sz[i] = 0;		}		for (int i = 0; i < x.length; i++) {			to[x[i]][sz[x[i]]++] = y[i];			to[y[i]][sz[y[i]]++] = x[i];		}		return to;	}  	public class SparseTable {		int pow;		int[] lessPow;		int[][] min; 		public SparseTable(int[] a) {			pow = 0;			while ((1 << pow) <= a.length) {				pow++;			}			min = new int[pow][a.length];			for (int i = 0; i < a.length; i++) {				min[0][i] = a[i];			}			for (int i = 1; i < pow; i++) {				for (int j = 0; j < a.length; j++) {					min[i][j] = min[i - 1][j];					if (j + (1 << (i - 1)) < a.length) {						min[i][j] = func(min[i][j], min[i - 1][j + (1 << (i - 1))]);					}				}			}			lessPow = new int[a.length + 1];			for (int i = 1; i < lessPow.length; i++) {				if (i < (1 << (lessPow[i - 1]) + 1)) {					lessPow[i] = lessPow[i - 1];				} else {					lessPow[i] = lessPow[i - 1] + 1;				}			}		} 		public int get(int l, int r) { // [l, r)			int p = lessPow[r - l];			return func(min[p][l], min[p][r - (1 << p)]);		} 		public int func(int a, int b) {			if (a < b) {				return a;			}			return b;		}	} 	public double check(int n, ArrayList<Integer> masks) {		int good = 0;		for (int colorMask = 0; colorMask < (1 << n); ++colorMask) {			int best = 2 << n;			int cnt = 0;			for (int curMask : masks) {				int curScore = 0;				for (int i = 0; i < n; ++i) {					if (((curMask >> i) & 1) == 1) {						if (((colorMask >> i) & 1) == 0) {							curScore += 1;						} else {							curScore += 2;						}					}				} 				if (curScore < best) {					best = curScore;					cnt = 1;				} else if (curScore == best) {					++cnt;				}			} 			if (cnt == 1) {				++good;			}		} 		return (double) good / (double) (1 << n);	} 	public int builtin_popcount(int x) {		int ans = 0;		for (int i = 0; i < 14; i++) {			if (((x >> i) & 1) > 0) {				ans++;			}		}		return ans;	} 	public int number(int[] x) {		int ans = 0;		for (int i = 0; i < x.length; i++) {			ans *= 3;			ans += x[i];		}		return ans;	} 	public int[] rotate(int[] x) {		int[] ans = { x[2], x[0], x[3], x[1] };		return ans;	} 	int MAX = 100000; 	boolean[] b = new boolean[MAX];	int[][] max0 = new int[MAX][2];	int[][] max1 = new int[MAX][2];	int[][] max2 = new int[MAX][2];	int[] index0 = new int[MAX];	int[] index1 = new int[MAX];	int[] p = new int[MAX]; 	public int place(String s) {		if (s.charAt(s.length() - 1) == '1') {			return 1;		}		int number = 16;		boolean w = true;		boolean a = true;		for (int i = 0; i < s.length(); i++) {			if (number == 1) {				return 2;			}			if (s.charAt(i) == '1') {				if (w) {					number /= 2;				} else {					if (a) {						a = false;					} else {						number /= 2;						a = true;					}				}			} else {				if (w) {					if (number == 16) {						w = false;						number /= 2;					} else {						w = false;						a = false;					}				} else {					if (number == 8) {						if (a) {							return 13;						} else {							return 9;						}					} else if (number == 4) {						if (a) {							return 7;						} else {							return 5;						}					} else if (a) {						return 4;					} else {						return 3;					}				}			}		}		return 0;	} 	public class P implements Comparable<P> {		Integer x;		String s; 		public P(Integer x, String s) {			this.x = x;			this.s = s;		} 		@Override		public String toString() {			return x + " " + s;		} 		@Override		public int compareTo(P o) {			if (x != o.x) {				return x - o.x;			}			return s.compareTo(o.s);		}	} 	public BigInteger prod(int l, int r) {		if (l + 1 == r) {			return BigInteger.valueOf(l);		}		int m = (l + r) >> 1;		return prod(l, m).multiply(prod(m, r));	} 	public class Frac {		BigInteger p;		BigInteger q; 		public Frac(BigInteger p, BigInteger q) {			BigInteger gcd = p.gcd(q);			this.p = p.divide(gcd);			this.q = q.divide(gcd);		} 		public String toString() {			return p + "\n" + q;		} 		public Frac(long p, long q) {			this(BigInteger.valueOf(p), BigInteger.valueOf(q));		} 		public Frac mul(Frac o) {			return new Frac(p.multiply(o.p), q.multiply(o.q));		} 		public Frac sum(Frac o) {			return new Frac(p.multiply(o.q).add(q.multiply(o.p)), q.multiply(o.q));		} 		public Frac diff(Frac o) {			return new Frac(p.multiply(o.q).subtract(q.multiply(o.p)), q.multiply(o.q));		}	} 	public void dfs(int v, int prev, int sum) {		sub[v] = -sum;		for (int i : to[v]) {			if (i == prev) {				continue;			}			dfs(i, v, sub[v]);		}		a[v] = sum - (-sum) * (to[v].length - 1);	} 	int[][] to;	int[][] size; 	int[] a;	int[] sub; 	public long calc(int[] a, int mean) {		long ans = 0;		long more = 0;		for (int q = 0; q < 2; q++) {			for (int i = 0; i < a.length; i++) {				if (a[i] > mean) {					more += a[i] - mean;					a[i] = mean;				} else {					if (mean - a[i] < more) {						more -= mean - a[i];						a[i] = mean;					} else {						a[i] += more;						more = 0;					}				}				ans += more;			}		}		return ans;	} 	int LOG = 31; 	public class DSUStrange {		int[] par;		int[] sz; 		public DSUStrange(int n) {			par = new int[n + 1];			sz = new int[n + 1];			for (int i = 1; i <= n; i++) {				par[i] = i;				sz[i] = 1;			}		} 		public int get(int x) {			if (x == par[x] || x == -par[x]) {				return par[x];			}			int next = par[x];			int sign = 1;			if (next < 0) {				sign = -1;				next *= -1;			}			return par[x] = sign * get(next);		} 		public void unite(int x, int y, boolean eq) {			int vx = get(x);			int sx = 1;			if (vx < 0) {				vx = -vx;				sx = -1;			}			int vy = get(y);			int sy = 1;			if (vy < 0) {				vy = -vy;				sy = -1;			}			if (vx == vy) {				return;			}			int s = (eq ? 1 : -1) * sx * sy;			if (sz[vx] >= sz[vy]) {				sz[vx] += sz[vy];				par[vy] = s * vx;			} else {				sz[vy] += sz[vx];				par[vx] = s * vy;			}		}	} 	public boolean check(int x, int y, int m, int n) {		return 0 <= x && x <= m && 0 <= y && y <= n;	} 	public boolean eqBit(int a, int b, int bit) {		return (((1 << bit) & a) ^ ((1 << bit) & b)) > 0;	} 	public int min(int a, int b) {		return a > b ? b : a;	} 	public int max(int a, int b) {		return a < b ? b : a;	} 	int inv3 = pow(3, mod - 2); 	int MAX1 = 500010; 	public class Array implements Comparable<Array> {		int[] a; 		public Array(int[] a) {			this.a = a;		} 		@Override		public int compareTo(Array o) {			if (o.a.length != a.length) {				return o.a.length - a.length;			}			for (int i = 0; i < a.length; i++) {				if (o.a[i] != a[i]) {					return o.a[i] - a[i];				}			}			return 0;		}	} 	public class ArrL implements Comparable<ArrL> {		Array arr;		ArrayList<Integer> ind; 		public ArrL(E.Array arr, ArrayList<Integer> ind) {			this.arr = arr;			this.ind = ind;		} 		@Override		public int compareTo(ArrL o) {			if (o.ind.size() != ind.size()) {				return o.ind.size() - ind.size();			}			return 0;		}	} 	public class DSUmy {		PriorityQueue<Pair>[] q;		int[] sz;		int[] par; 		@SuppressWarnings("unchecked")		public DSUmy(int n) {			q = new PriorityQueue[n];			par = new int[n];			sz = new int[n];			for (int i = 0; i < n; i++) {				par[i] = i;				sz[i] = 1;				q[i] = new PriorityQueue<>();			}		} 		public int get(int v) {			if (par[v] == v) {				return v;			}			return par[v] = get(par[v]);		} 		public int unite(int a, int b) {			a = get(a);			b = get(b);			if (a == b) {				return a;			}			if (sz[a] < sz[b]) {				a ^= b;				b ^= a;				a ^= b;			}			sz[a] += sz[b];			par[b] = a;			if (q[a].size() >= q[b].size()) {				while (!q[b].isEmpty()) {					q[a].add(q[b].poll());				}			} else {				while (!q[a].isEmpty()) {					q[b].add(q[a].poll());				}				q[a] = q[b];			}			return a;		}	} 	public class Trip implements Comparable<Trip> {		int l;		int r;		int t; 		public Trip(int l, int r, int t) {			this.l = l;			this.r = r;			this.t = t;		} 		@Override		public int compareTo(Trip o) {			return r - o.r;		} 	} 	int N = 100010;	int[] fact = new int[N];	int[] ifact = new int[N];		public int c_n_k(int n, int k) {		if (k < 0 || k > n || n < 0) {			return 0;		}		return mult(fact[n], mult(ifact[k], ifact[n - k]));	}		public void solve() {		int n = in.nextInt();		int k = in.nextInt();		int[] a = new int[n];		String s = in.next();		int[][] pref = new int[3][n + 1];		for (int i = 0; i < n; ++i) {			for (int j = 0; j < 3; ++j) {				pref[j][i + 1] = pref[j][i];			}			if (s.charAt(i) == '0') {				++pref[0][i + 1];				a[i] = 0;			} else if (s.charAt(i) == '1') {				++pref[1][i + 1];				a[i] = 1;			} else {				++pref[2][i + 1];				a[i] = 2;			}		}		--k;		int ans = 0;		if (pref[0][n] == 0) {			++ans;		}		if (pref[1][n] == 0) {			++ans;		}		int[] x = new int[k];		for (int i = 0; i < k; ++i) {			x[i] = 2;		}		int bad0 = 0;		int bad1 = 0;		int[] p = new int[k + 1];		p[0] = 1;		for (int i = 0; i < k; ++i) {			p[i + 1] = mult(p[i], 2);		}		int[] ni = new int[3];		for (int i = n; i > 0; --i) {			if (i != n) {				int md = (n - 1 - i) % k;				int v = x[md];				if (v == 1 || v == 2) {					int n0 = ni[0];					int n1 = ni[1];					int n2 = ni[2];					if (v == 2) {						--n2;						++n1;					}					if (pref[1][i] == 0) {						if (n - i > k) {							ans = sum(ans, c_n_k(n2, k / 2 - n1));						} else {							ans = sum(ans, diff(p[n2], bad1));						}					}				}				if (v == 0 || v == 2) {					int n0 = ni[0];					int n1 = ni[1];					int n2 = ni[2];					if (v == 2) {						--n2;						++n0;					}					if (pref[0][i] == 0) {						if (n - i > k) {							ans = sum(ans, c_n_k(n2, k / 2 - n0));						} else {							ans = sum(ans, diff(p[n2], bad0));						}					}				}	}			if (i == 0) {				break;			}			int mod = (n - i) % k;			int val = a[i - 1];			if (i < n) {				int v = a[i];				if (v == 2) {					bad0 = mult(bad0, 2);					bad1 = mult(bad1, 2);					bad0 = sum(bad0, c_n_k(ni[2] - 1, k / 2 - 1 - ni[0]));					bad1 = sum(bad1, c_n_k(ni[2] - 1, k / 2 - 1 - ni[1]));				} else if (v == 1) {					bad1 = sum(bad1, c_n_k(ni[2], k / 2 - ni[1]));				} else if (v == 0) {					bad0 = sum(bad0, c_n_k(ni[2], k / 2 - ni[0]));				}			}			if (n - i < k) {				x[mod] = val;				++ni[val];			} else {				if (val != 2) {					if (x[mod] == 2) {						--ni[2];						x[mod] = val;						++ni[val];					} else if (x[mod] != val) {						break;					}				}			}		}		out.println(ans);	} 	public boolean check(String s) {		if (s.equals("0")) {			return true;		}		if (s.charAt(0) == '0') {			return false;		}		if (Long.parseLong(s) >= mod) {			return false;		}		return true;	} 	public void add(Map<Integer, Integer> map, int x) {		if (map.containsKey(x)) {			map.put(x, map.get(x) + 1);		} else {			map.put(x, 1);		}	} 	public void run() {		try {			if (systemIO) {				in = new FastScanner(System.in);				out = new PrintWriter(System.out);			} else {				in = new FastScanner(new File("input.txt"));				out = new PrintWriter(new File("output.txt"));			} 			fact[0] = 1;			for (int i = 0; i < N - 1; ++i) {				fact[i + 1] = mult(fact[i], i + 1);			}			ifact[N - 1] = inv(fact[N - 1]);			for (int i = N - 1; i > 0; --i) {				ifact[i - 1] = mult(ifact[i], i);			}						int t = 1;			t = in.nextInt();			for (int i = 0; i < t; i++) {				solve();			} 			out.close();		} catch (IOException e) {			e.printStackTrace();		}	} 	class FastScanner {		BufferedReader br;		StringTokenizer st; 		FastScanner(File f) {			try {				br = new BufferedReader(new FileReader(f));			} catch (FileNotFoundException e) {				e.printStackTrace();			}		} 		FastScanner(InputStream f) {			br = new BufferedReader(new InputStreamReader(f));		} 		String nextLine() {			try {				return br.readLine();			} catch (IOException e) {				return null;			}		} 		String next() {			while (st == null || !st.hasMoreTokens()) {				try {					st = new StringTokenizer(br.readLine());				} catch (IOException e) {					e.printStackTrace();				}			}			return st.nextToken();		} 		int nextInt() {			return Integer.parseInt(next());		} 		long nextLong() {			return Long.parseLong(next());		} 		double nextDouble() {			return Double.parseDouble(next());		} 	} 	public static void main(String[] arg) {		long time = System.currentTimeMillis();		new E().run();		System.err.println(System.currentTimeMillis() - time);	}}