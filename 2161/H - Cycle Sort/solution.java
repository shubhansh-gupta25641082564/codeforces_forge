import java.io.*;import java.util.*; public class Main {    static final class FastScanner {        private final InputStream in;        private final byte[] buffer = new byte[1 << 16];        private int ptr = 0, len = 0;         FastScanner(InputStream is) { in = is; }         private int read() throws IOException {            if (ptr >= len) {                len = in.read(buffer);                ptr = 0;                if (len <= 0) return -1;            }            return buffer[ptr++];        }         long nextLong() throws IOException {            int c;            do {                c = read();                if (c == -1) return Long.MIN_VALUE;            } while (c <= ' ');            long sgn = 1;            if (c == '-') {                sgn = -1;                c = read();            }            long val = 0;            while (c > ' ') {                val = val * 10 + (c - '0');                c = read();            }            return val * sgn;        }         int nextInt() throws IOException { return (int) nextLong(); }    }     static final class IntMaxHeap {        int[] h = new int[0];        int sz = 0;         void clear() { sz = 0; }         void push(int v) {            if (h.length == 0) h = new int[4];            if (sz == h.length) h = Arrays.copyOf(h, h.length << 1);            h[sz] = v;            int i = sz++;            while (i > 0) {                int p = (i - 1) >>> 1;                if (h[p] >= h[i]) break;                int t = h[p]; h[p] = h[i]; h[i] = t;                i = p;            }        }         int top() { return h[0]; }         int pop() {            int res = h[0];            int v = h[--sz];            if (sz > 0) {                h[0] = v;                int i = 0;                while (true) {                    int l = i * 2 + 1;                    if (l >= sz) break;                    int r = l + 1;                    int mx = (r < sz && h[r] > h[l]) ? r : l;                    if (h[i] >= h[mx]) break;                    int t = h[i]; h[i] = h[mx]; h[mx] = t;                    i = mx;                }            }            return res;        }    }     static final int N = 600000 + 7;     static int bn, bm, n, m;    static int[] A = new int[N], B = new int[N], a = new int[N], b = new int[N], pos = new int[N], id = new int[N];    static long[] c = new long[N];    static long k, K;    static IntMaxHeap[] p = new IntMaxHeap[N];     static int[] stLz = new int[N << 2];    static int[] stFi = new int[N << 2];    static int[] stSe = new int[N << 2];     static long packPair(int fi, int se) {        return (((long) fi) << 32) | (se & 0xffffffffL);    }     static int pairFi(long v) { return (int) (v >> 32); }    static int pairSe(long v) { return (int) v; }     static long minPair(long x, long y) {        int x1 = pairFi(x), y1 = pairFi(y);        if (x1 != y1) return x1 < y1 ? x : y;        int x2 = pairSe(x), y2 = pairSe(y);        return x2 <= y2 ? x : y;    }     static void bt(int l, int r, int o) {        stLz[o] = 0;        stFi[o] = -r;        stSe[o] = -r;        if (l == r) return;        int mid = (l + r) >>> 1;        bt(l, mid, o << 1);        bt(mid + 1, r, o << 1 | 1);    }     static void tag(int o, int delta) {        stLz[o] += delta;        stFi[o] += delta;    }     static void down(int o) {        int lz = stLz[o];        if (lz != 0) {            tag(o << 1, lz);            tag(o << 1 | 1, lz);            stLz[o] = 0;        }    }     static void up(int o) {        int l = o << 1, r = o << 1 | 1;        if (stFi[l] < stFi[r] || (stFi[l] == stFi[r] && stSe[l] <= stSe[r])) {            stFi[o] = stFi[l];            stSe[o] = stSe[l];        } else {            stFi[o] = stFi[r];            stSe[o] = stSe[r];        }    }     static void updSeg(int l, int r, int o, int x, int y) {        if (x <= l) {            tag(o, y);            return;        }        int mid = (l + r) >>> 1;        down(o);        if (x <= mid) updSeg(l, mid, o << 1, x, y);        updSeg(mid + 1, r, o << 1 | 1, x, y);        up(o);    }     static long qmin(int l, int r, int o, int x) {        if (r <= x) return packPair(stFi[o], stSe[o]);        int mid = (l + r) >>> 1;        down(o);        if (x <= mid) return qmin(l, mid, o << 1, x);        return minPair(qmin(l, mid, o << 1, x), qmin(mid + 1, r, o << 1 | 1, x));    }     static int qry(int l, int r, int o, int y) {        if (stFi[o] >= y) return -1;        if (l == r) return l;        int mid = (l + r) >>> 1;        down(o);        int w = qry(l, mid, o << 1, y);        return w == -1 ? qry(mid + 1, r, o << 1 | 1, y) : w;    }     static void upd3(int x, int y) {        int R = n * 3;        updSeg(0, R, 1, x, y);        updSeg(0, R, 1, n + x, y);        updSeg(0, R, 1, n + n + x, y);    }     static void calc() {        for (int i = 1; i <= n; i++) c[i] = (((long) a[i]) << 32) | (i & 0xffffffffL);        for (int i = 1; i <= m; i++) c[n + i] = (((long) b[i]) << 32) | ((n + i) & 0xffffffffL);        Arrays.sort(c, 1, n + m + 1);         for (int i = 1; i <= n; i++) {            pos[i] = (int) (((1L * i * m - 1) % n) + 1);            id[pos[i]] = i;        }         bt(0, n * 3, 1);         for (int i = 1; i <= n; i++) {            if (p[i] != null) p[i].clear();        }         for (int i = 1; i <= n + m; i++) {            int val = (int) (c[i] >> 32);            int idx = (int) c[i];             int x = idx;            int y = -1;            if (x > n) {                x -= n;                y = x;            }            x = id[(x - 1) % n + 1];             long w = qmin(0, n * 3, 1, n + x - 1);            int wFi = pairFi(w);            int wSe = -pairSe(w);             int z = qry(0, n * 3, 1, wFi);             if (p[x] == null) p[x] = new IntMaxHeap();            p[x].push(y);             upd3(x, 1);             int bucket = (wSe % n) + 1;            int top = p[bucket].top();             long expr = 1L * (z - wSe - 1) * m + top;             if (z == -1 || expr > k) {                b[top] = val;                p[bucket].pop();                upd3(bucket, -1);            } else {                a[pos[(z - 1) % n + 1]] = val;            }        }    }     static int gcd(int x, int y) {        while (y != 0) {            int t = x % y;            x = y;            y = t;        }        return x;    }     static void work(FastScanner fs, StringBuilder out) throws Exception {        bn = fs.nextInt();        bm = fs.nextInt();        K = fs.nextLong();         for (int i = 1; i <= bn; i++) A[i] = fs.nextInt();        for (int i = 1; i <= bm; i++) B[i] = fs.nextInt();         int g = gcd(bn, bm);        for (int i = g; i >= 1; i--) {            n = 0;            m = 0;            k = K / g + ((K % g) >= i ? 1 : 0);             for (int j = i; j <= bn; j += g) a[++n] = A[j];            for (int j = i; j <= bm; j += g) b[++m] = B[j];             calc();             n = 0;            m = 0;            for (int j = i; j <= bn; j += g) A[j] = a[++n];            for (int j = i; j <= bm; j += g) B[j] = b[++m];        }         for (int i = 1; i <= bn; i++) {            if (i > 1) out.append(' ');            out.append(A[i]);        }        out.append('\n');         for (int i = 1; i <= bm; i++) {            if (i > 1) out.append(' ');            out.append(B[i]);        }        out.append('\n');    }     public static void main(String[] args) throws Exception {        FastScanner fs = new FastScanner(System.in);        StringBuilder out = new StringBuilder();        int T = fs.nextInt();        while (T-- > 0) work(fs, out);        System.out.print(out.toString());    }}