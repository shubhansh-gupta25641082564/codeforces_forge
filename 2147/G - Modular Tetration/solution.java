import java.util.*; public class Main {    static final int MOD = 998244353;    static final int LIM = 1_000_000;    static int[] spf = new int[LIM + 1];    static int[] invv = new int[LIM + 1];     public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        buildSPF();        buildInverse();         int T = sc.nextInt();        while (T-- > 0) {            int x = sc.nextInt();            int y = sc.nextInt();            int z = sc.nextInt();             HashMap<Integer, Integer> cnt = new HashMap<>();            factorizeInt(x, cnt);            factorizeInt(y, cnt);            factorizeInt(z, cnt);             long ans = 1;            ArrayList<Integer> primes_m = new ArrayList<>();            for (Map.Entry<Integer, Integer> kv : cnt.entrySet()) {                int p = kv.getKey();                int k = kv.getValue();                primes_m.add(p);                ans = ans * (p - 1) % MOD;                ans = ans * modPow(invv[p], k) % MOD;            }             HashMap<Integer, Integer> E = new HashMap<>();            for (int p : primes_m) {                int t = p - 1;                factorizeInt(t, E);            }             HashSet<Integer> Pset = new HashSet<>(primes_m);            for (Map.Entry<Integer, Integer> kv : E.entrySet()) {                int r = kv.getKey();                int e = kv.getValue();                if (Pset.contains(r)) {                    ans = ans * modPow(invv[r], e) % MOD;                } else {                    long invr = invv[r];                    long invrE = modPow(invr, e);                    long term = (invr + ((1 - invr + MOD) % MOD) * invrE) % MOD;                    ans = ans * term % MOD;                }            }             System.out.println(ans);        }    }     static void buildSPF() {        Arrays.fill(spf, 0);        spf[1] = 1;        ArrayList<Integer> primes = new ArrayList<>();        for (int i = 2; i <= LIM; i++) {            if (spf[i] == 0) {                spf[i] = i;                primes.add(i);            }            for (int p : primes) {                if ((long)p * i > LIM) break;                spf[p * i] = p;                if (p == spf[i]) break;            }        }    }     static void buildInverse() {        invv[1] = 1;        for (int i = 2; i <= LIM; i++) {            invv[i] = (int)((long)(MOD - MOD / i) * invv[MOD % i] % MOD);        }    }     static long modPow(long a, long e) {        long r = 1 % MOD;        while (e > 0) {            if ((e & 1) != 0) r = r * a % MOD;            a = a * a % MOD;            e >>= 1;        }        return r;    }     static void factorizeInt(int n, HashMap<Integer, Integer> cnt) {        if (n <= 1) return;        while (n > 1) {            int p = spf[n];            int c = 0;            while (n % p == 0) {                n /= p;                c++;            }            cnt.put(p, cnt.getOrDefault(p, 0) + c);        }    }}