import java.io.*;import java.util.*; public class Main {    static class PushRelabel {        static class Edge {            int dest, back;            long f, c;            Edge(int dest, int back, long f, long c) { this.dest = dest; this.back = back; this.f = f; this.c = c; }        }        ArrayList<ArrayList<Edge>> g;        long[] ec;        int[] cur;        ArrayList<ArrayList<Integer>> hs;        int[] H;        PushRelabel(int n) {            g = new ArrayList<>(n);            for (int i = 0; i < n; i++) g.add(new ArrayList<>());            ec = new long[n];            cur = new int[n];            hs = new ArrayList<>();            for (int i = 0; i < 2*n; i++) hs.add(new ArrayList<>());            H = new int[n];        }        void addEdge(int s, int t, long cap, long rcap) {            if (s == t) return;            ArrayList<Edge> gs = g.get(s);            ArrayList<Edge> gt = g.get(t);            gs.add(new Edge(t, gt.size(), 0, cap));            gt.add(new Edge(s, gs.size()-1, 0, rcap));        }        void addFlow(int u, int ei, long fval) {            Edge e = g.get(u).get(ei);            Edge back = g.get(e.dest).get(e.back);            if (ec[e.dest] == 0 && fval > 0) hs.get(H[e.dest]).add(e.dest);            e.f += fval; e.c -= fval; ec[e.dest] += fval;            back.f -= fval; back.c += fval; ec[back.dest] -= fval;        }        long calc(int s, int t) {            int v = g.size();            Arrays.fill(H, 0);            H[s] = v;            Arrays.fill(ec, 0);            ec[t] = 1;            int[] co = new int[2*v];            co[0] = v-1;            for (int i = 0; i < v; i++) cur[i] = 0;            for (int ei = 0; ei < g.get(s).size(); ei++) {                Edge e = g.get(s).get(ei);                if (e.c > 0) addFlow(s, ei, e.c);            }            for (int hi = 0;;) {                while (hs.get(hi).isEmpty()) {                    if (hi == 0) return -ec[s];                    hi--;                }                int u = hs.get(hi).remove(hs.get(hi).size()-1);                while (ec[u] > 0) {                    if (cur[u] == g.get(u).size()) {                        H[u] = Integer.MAX_VALUE / 2;                        for (int ei = 0; ei < g.get(u).size(); ei++) {                            Edge e = g.get(u).get(ei);                            if (e.c > 0 && H[u] > H[e.dest] + 1) {                                H[u] = H[e.dest] + 1;                                cur[u] = ei;                            }                        }                        co[H[u]]++;                        co[hi]--;                        if (co[hi] == 0 && hi < v) {                            for (int i = 0; i < v; i++) if (hi < H[i] && H[i] < v) {                                co[H[i]]--; H[i] = v + 1;                            }                        }                        hi = H[u];                    } else {                        Edge e = g.get(u).get(cur[u]);                        if (e.c > 0 && H[u] == H[e.dest] + 1) {                            long add = Math.min(ec[u], e.c);                            addFlow(u, cur[u], add);                        } else cur[u]++;                    }                }            }        }        boolean leftOfMinCut(int a) { return H[a] >= g.size(); }    }     static class Flow {        int[][] am;        PushRelabel fl;        Flow(int[][] _am) {            am = _am;            int n = am.length;            fl = new PushRelabel(n);            for (int u = 0; u < n; u++) for (int v = u+1; v < n; v++) if (am[u][v] != 0) fl.addEdge(u, v, am[u][v], am[u][v]);        }        long calc(int u, int v) {            int n = am.length;            fl = new PushRelabel(n);            for (int i = 0; i < n; i++) for (int j = i+1; j < n; j++) if (am[i][j] != 0) fl.addEdge(i, j, am[i][j], am[i][j]);            return fl.calc(u, v);        }        boolean leftOfMinCut(int u) { return fl.leftOfMinCut(u); }    }     static long[] gomoryHu(int N, Flow fl) {        long[] tree = new long[3*(N-1)];        int[] par = new int[N];        int idx = 0;        for (int i = 1; i < N; i++) {            long cut = fl.calc(i, par[i]);            tree[idx++] = i; tree[idx++] = par[i]; tree[idx++] = cut;            for (int j = i+1; j < N; j++) if (par[j] == par[i] && fl.leftOfMinCut(j)) par[j] = i;        }        return tree;    }     static long gcd(long x, long y) {        if (y == 0) return x;        return gcd(y, x % y);    }     static boolean is_good(int[][] am) {        int n = am.length;        Flow f = new Flow(am);        long[] ght = gomoryHu(n, f);        long g = 0;        for (int i = 0; i < ght.length; i += 3) g = gcd(g, Math.abs(ght[i+2]));        return g != 1;    }     static int[] even_decomposition(int[][] am) {        int n = am.length;        for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) am[i][j] &= 1;        int[] part = new int[n];        Arrays.fill(part, 0);        ArrayList<Integer> st = new ArrayList<>();        while (true) {            int ov = -1;            for (int u = 0; u < n; u++) {                if (part[u] == -1) continue;                int d = 0;                for (int v = 0; v < n; v++) if (am[u][v] != 0 && part[v] != -1) d++;                if ((d & 1) == 1) { ov = u; break; }            }            if (ov == -1) break;            for (int u = 0; u < n; u++) {                if (am[ov][u] == 0 || part[u] == -1) continue;                for (int v = u+1; v < n; v++) {                    if (am[ov][v] == 0 || part[v] == -1) continue;                    am[u][v] ^= 1; am[v][u] ^= 1;                }            }            part[ov] = -1;            st.add(ov);        }        Collections.reverse(st);        for (int ov : st) {            int[] dp = new int[2];            for (int u = 0; u < n; u++) {                if (am[ov][u] == 0 || part[u] == -1) continue;                dp[part[u]]++;                for (int v = u+1; v < n; v++) {                    if (am[ov][v] == 0 || part[v] == -1) continue;                    am[u][v] ^= 1; am[v][u] ^= 1;                }            }            part[ov] = dp[0] % 2;        }        return part;    }     public static void main(String[] args) throws Exception {        FastScanner fs = new FastScanner(System.in);        int T = fs.nextInt();        StringBuilder out = new StringBuilder();        while (T-- > 0) {            int n = fs.nextInt();            int m = fs.nextInt();            int[][] am = new int[n][n];            for (int i = 0; i < m; i++) {                int u = fs.nextInt();                int v = fs.nextInt();                int w = fs.nextInt();                u--; v--;                am[u][v] = am[v][u] = w;            }            if (is_good(am)) {                out.append(1).append('\n');                out.append(n).append('\n');                for (int i = 0; i < n; i++) {                    if (i > 0) out.append(' ');                    out.append(i+1);                }                out.append('\n');            } else {                int[] v = even_decomposition(am);                out.append(2).append('\n');                int l = 0;                for (int i = 0; i < n; i++) l += v[i];                out.append(l).append('\n');                boolean pr = false;                for (int i = 0; i < n; i++) if (v[i] == 1) {                    if (pr) out.append(' ');                    out.append(i+1); pr = true;                }                out.append('\n');                pr = false;                out.append(n - l).append('\n');                for (int i = 0; i < n; i++) if (v[i] == 0) {                    if (pr) out.append(' ');                    out.append(i+1); pr = true;                }                out.append('\n');            }        }        System.out.print(out.toString());    }     static class FastScanner {        private final InputStream in;        private final byte[] buffer = new byte[1 << 16];        private int ptr = 0, len = 0;        FastScanner(InputStream is) { in = is; }        private int read() throws IOException {            if (ptr >= len) {                len = in.read(buffer);                ptr = 0;                if (len <= 0) return -1;            }            return buffer[ptr++];        }        int nextInt() throws IOException {            int c;            while ((c = read()) <= ' ') if (c == -1) return Integer.MIN_VALUE;            int sign = 1;            if (c == '-') { sign = -1; c = read(); }            int val = 0;            while (c > ' ') { val = val * 10 + (c - '0'); c = read(); }            return val * sign;        }    }}