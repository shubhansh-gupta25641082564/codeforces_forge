import java.io.*;import java.util.*; public class Main {    static class Edge { int to, id; Edge(int t, int i){to=t;id=i;} }    static class Pair { int v, id; Pair(int _v,int _id){v=_v;id=_id;} }     public static void main(String[] args) throws Exception {        FastScanner fs = new FastScanner(System.in);        StringBuilder out = new StringBuilder();        int t = fs.nextInt();        while (t-- > 0) {            int n = fs.nextInt();            int m = fs.nextInt();            ArrayList<Edge>[] g = new ArrayList[n+1];            for (int i = 1; i <= n; ++i) g[i] = new ArrayList<>();            int[] eu = new int[m+1], ev = new int[m+1];            for (int i = 1; i <= m; ++i) {                int u = fs.nextInt();                int v = fs.nextInt();                eu[i] = u; ev[i] = v;                g[u].add(new Edge(v, i));                g[v].add(new Edge(u, i));            }             int[] tin = new int[n+1], low = new int[n+1];            boolean[] vis = new boolean[n+1];            boolean[] isBridge = new boolean[m+1];            int[] timer = new int[1]; // make timer effectively final by using array             // recursive DFS inside local class (timer is an array so it's effectively final)            class Rec {                void dfs(int u, int pe) {                    vis[u] = true;                    tin[u] = low[u] = ++timer[0];                    for (Edge e : g[u]) {                        int v = e.to, id = e.id;                        if (id == pe) continue;                        if (vis[v]) {                            low[u] = Math.min(low[u], tin[v]);                        } else {                            dfs(v, id);                            low[u] = Math.min(low[u], low[v]);                            if (low[v] > tin[u]) isBridge[id] = true;                        }                    }                }            }            Rec r = new Rec();            for (int i = 1; i <= n; ++i) if (!vis[i]) r.dfs(i, -1);             int[] comp = new int[n+1];            Arrays.fill(comp, -1);            int compCnt = 0;            for (int i = 1; i <= n; ++i) {                if (comp[i] != -1) continue;                Deque<Integer> dq = new ArrayDeque<>();                dq.add(i);                comp[i] = compCnt;                while (!dq.isEmpty()) {                    int u = dq.poll();                    for (Edge e : g[u]) {                        int v = e.to, id = e.id;                        if (isBridge[id]) continue;                        if (comp[v] == -1) {                            comp[v] = compCnt;                            dq.add(v);                        }                    }                }                compCnt++;            }             ArrayList<Pair>[] tree = new ArrayList[compCnt];            for (int i = 0; i < compCnt; ++i) tree[i] = new ArrayList<>();            for (int id = 1; id <= m; ++id) {                if (isBridge[id]) {                    int a = comp[eu[id]], b = comp[ev[id]];                    tree[a].add(new Pair(b, id));                    tree[b].add(new Pair(a, id));                }            }             int comp1 = comp[1], compn = comp[n];            boolean[] requiredBridge = new boolean[m+1];            if (comp1 != compn) {                int[] parent = new int[compCnt];                int[] parentEdge = new int[compCnt];                Arrays.fill(parent, -1);                Deque<Integer> dq = new ArrayDeque<>();                dq.add(comp1);                parent[comp1] = comp1;                parentEdge[comp1] = -1;                while (!dq.isEmpty()) {                    int u = dq.poll();                    if (u == compn) break;                    for (Pair p : tree[u]) {                        if (parent[p.v] == -1) {                            parent[p.v] = u;                            parentEdge[p.v] = p.id;                            dq.add(p.v);                        }                    }                }                int cur = compn;                while (cur != comp1) {                    int e = parentEdge[cur];                    requiredBridge[e] = true;                    cur = parent[cur];                }            }             int q = fs.nextInt();            int[] queries = new int[q];            for (int i = 0; i < q; ++i) queries[i] = fs.nextInt();             boolean anyRequired = false;            for (int i = 1; i <= m; ++i) if (requiredBridge[i]) { anyRequired = true; break; }            if (!anyRequired) {                for (int i = 0; i < q; ++i) {                    out.append("-1");                    if (i+1 < q) out.append(' ');                }                out.append('\n');                continue;            }             int INF = 1_000_000_000;            int[] bestDist = new int[n+1];            int[] bestIdx = new int[n+1];            Arrays.fill(bestDist, INF);            Arrays.fill(bestIdx, INF);            int[] endpointMin = new int[n+1];            Arrays.fill(endpointMin, INF);            for (int id = 1; id <= m; ++id) {                if (!requiredBridge[id]) continue;                int a = eu[id], b = ev[id];                endpointMin[a] = Math.min(endpointMin[a], id);                endpointMin[b] = Math.min(endpointMin[b], id);            }             PriorityQueue<long[]> pq = new PriorityQueue<>(new Comparator<long[]>() {                public int compare(long[] a, long[] b) {                    if (a[0] != b[0]) return Long.compare(a[0], b[0]);                    return Long.compare(a[1], b[1]);                }            });             for (int v = 1; v <= n; ++v) {                if (endpointMin[v] != INF) {                    bestDist[v] = 0;                    bestIdx[v] = endpointMin[v];                    pq.add(new long[]{0, bestIdx[v], v});                }            }             while (!pq.isEmpty()) {                long[] cur = pq.poll();                int d = (int)cur[0];                int idx = (int)cur[1];                int u = (int)cur[2];                if (d != bestDist[u] || idx != bestIdx[u]) continue;                for (Edge e : g[u]) {                    int v = e.to;                    int nd = d + 1;                    int nidx = idx;                    if (nd < bestDist[v] || (nd == bestDist[v] && nidx < bestIdx[v])) {                        bestDist[v] = nd;                        bestIdx[v] = nidx;                        pq.add(new long[]{nd, nidx, v});                    }                }            }             for (int i = 0; i < q; ++i) {                int c = queries[i];                if (bestIdx[c] == INF) out.append("-1");                else out.append(bestIdx[c]);                if (i+1 < q) out.append(' ');            }            out.append('\n');        }        System.out.print(out.toString());    }     static class FastScanner {        private final InputStream in;        private final byte[] buffer = new byte[1 << 16];        private int ptr = 0, len = 0;        FastScanner(InputStream is) { in = is; }        private int read() throws IOException {            if (ptr >= len) {                len = in.read(buffer);                ptr = 0;                if (len <= 0) return -1;            }            return buffer[ptr++];        }        int nextInt() throws IOException {            int c;            while ((c = read()) <= ' ') if (c == -1) return -1;            int sgn = 1;            if (c == '-') { sgn = -1; c = read(); }            int val = 0;            while (c > ' ') {                val = val * 10 + (c - '0');                c = read();            }            return val * sgn;        }    }}