import java.io.*;import java.util.*; public class Main {    static final long MOD = 1_000_000_007L;     static int removeBit(int msk, int pos) {        int low = msk & ((1 << pos) - 1);        int high = msk >> (pos + 1);        return (high << pos) | low;    }     // Fast scanner    static final class FastScanner {        private final InputStream in;        private final byte[] buffer = new byte[1 << 16];        private int ptr = 0, len = 0;        FastScanner(InputStream is) { in = is; }        private int read() throws IOException {            if (ptr >= len) {                len = in.read(buffer);                ptr = 0;                if (len <= 0) return -1;            }            return buffer[ptr++];        }        int nextInt() throws IOException {            int c;            while ((c = read()) <= ' ') if (c == -1) return Integer.MIN_VALUE;            int sign = 1;            if (c == '-') { sign = -1; c = read(); }            int val = 0;            while (c > ' ') {                val = val * 10 + (c - '0');                c = read();            }            return val * sign;        }    }     public static void main(String[] args) throws Exception {        FastScanner fs = new FastScanner(System.in);        int t = fs.nextInt();        StringBuilder out = new StringBuilder();        while (t-- > 0) {            int n = fs.nextInt();            int m = fs.nextInt();            int k = fs.nextInt();            int[] good = new int[k];            for (int i = 0; i < k; ++i) good[i] = fs.nextInt();             // prevA/prevB for p = 1            boolean[] prevA = new boolean[2];            boolean[] prevB = new boolean[2];            prevA[0] = false; prevA[1] = true;            prevB[0] = false; prevB[1] = true;             for (int p = 2; p <= n; ++p) {                int size = 1 << p;                boolean[] currA = new boolean[size];                boolean[] currB = new boolean[size];                 // build Cp: good indices <= p                int cntCp = 0;                for (int v : good) if (v <= p) cntCp++;                int[] Cp = new int[cntCp];                int idx = 0;                for (int v : good) {                    if (v <= p) Cp[idx++] = v;                    else break;                }                 for (int mask = 0; mask < size; ++mask) {                    // Alice's turn (max => OR over children evaluated on Bob)                    boolean resA = false;                    for (int rIdx = 0; rIdx < Cp.length; ++rIdx) {                        int r = Cp[rIdx];                        int child = removeBit(mask, r - 1);                        if (prevB[child]) { resA = true; break; }                    }                    currA[mask] = resA;                     // Bob's turn (min => AND over children evaluated on Alice)                    boolean resB = true;                    for (int rIdx = 0; rIdx < Cp.length; ++rIdx) {                        int r = Cp[rIdx];                        int child = removeBit(mask, r - 1);                        if (!prevA[child]) { resB = false; break; }                    }                    currB[mask] = resB;                }                prevA = currA;                prevB = currB;            }             // cnt[s] = number of masks (over n piles) where Alice (starting) can force final bit = 1            int[] cnt = new int[n + 1];            int fullSize = 1 << n;            for (int mask = 0; mask < fullSize; ++mask) {                if (prevA[mask]) {                    int pc = Integer.bitCount(mask);                    cnt[pc]++;                }            }             long ans = 0;            // For each threshold T=1..m, contribution = sum_s cnt[s] * (m-T+1)^s * (T-1)^(n-s)            for (int T = 1; T <= m; ++T) {                long base1 = (m - T + 1) % MOD;                long base0 = (T - 1) % MOD;                long[] pow1 = new long[n + 1];                long[] pow0 = new long[n + 1];                pow1[0] = 1;                pow0[0] = 1;                for (int i = 1; i <= n; ++i) {                    pow1[i] = (pow1[i - 1] * base1) % MOD;                    pow0[i] = (pow0[i - 1] * base0) % MOD;                }                long sumT = 0;                for (int s = 0; s <= n; ++s) {                    if (cnt[s] == 0) continue;                    long add = ( (pow1[s] * pow0[n - s]) % MOD ) * cnt[s] % MOD;                    sumT += add;                    if (sumT >= MOD) sumT -= MOD;                }                ans += sumT;                if (ans >= MOD) ans -= MOD;            }             out.append(ans % MOD).append('\n');        }        System.out.print(out.toString());    }}