import java.io.*;import java.util.*; public class Main {    static class FastScanner {        private final InputStream in;        private final byte[] buffer = new byte[1 << 16];        private int ptr = 0, len = 0;        FastScanner(InputStream is) { in = is; }        private int read() throws IOException {            if (ptr >= len) {                len = in.read(buffer);                ptr = 0;                if (len <= 0) return -1;            }            return buffer[ptr++];        }        int nextInt() throws IOException {            int c;            while ((c = read()) <= ' ') if (c == -1) return Integer.MIN_VALUE;            int sign = 1;            if (c == '-') { sign = -1; c = read(); }            int val = 0;            while (c > ' ') { val = val * 10 + (c - '0'); c = read(); }            return val * sign;        }    }     static int MAXM = 0;    static int[] spf;    static int[] mu;    static ArrayList<Integer> primes = new ArrayList<>();     static void buildSieve(int M) {        if (M <= MAXM) return;        spf = new int[M + 1];        mu = new int[M + 1];        primes.clear();        mu[1] = 1;        for (int i = 2; i <= M; ++i) {            if (spf[i] == 0) {                spf[i] = i;                primes.add(i);                mu[i] = -1;            }            for (int p : primes) {                long v = 1L * p * i;                if (v > M) break;                spf[(int) v] = p;                if (i % p == 0) {                    mu[(int) v] = 0;                    break;                } else {                    mu[(int) v] = -mu[i];                }            }        }        MAXM = M;        mu[1] = 1;        spf[1] = 1;    }     static int gcd(int a, int b) {        while (b != 0) {            int t = a % b; a = b; b = t;        }        return a;    }     public static void main(String[] args) throws Exception {        FastScanner fs = new FastScanner(System.in);        StringBuilder out = new StringBuilder();        int T = fs.nextInt();        int globalMaxM = 0;        int[][] As = new int[T][];        int[] ns = new int[T];        int[] ms = new int[T];        for (int tc = 0; tc < T; ++tc) {            int n = fs.nextInt();            int m = fs.nextInt();            ns[tc] = n;            ms[tc] = m;            As[tc] = new int[n];            for (int i = 0; i < n; ++i) As[tc][i] = fs.nextInt();            if (m > globalMaxM) globalMaxM = m;        }        buildSieve(globalMaxM);        for (int tc = 0; tc < T; ++tc) {            int n = ns[tc];            int m = ms[tc];            int[] a = As[tc];            int maxVal = m;            int[] cntVal = new int[maxVal + 1];            for (int i = 0; i < n; ++i) cntVal[a[i]]++;            int[] f = new int[maxVal + 1];            for (int d = 1; d <= maxVal; ++d) {                int sum = 0;                for (int mult = d; mult <= maxVal; mult += d) {                    if (cntVal[mult] != 0) sum += cntVal[mult];                }                f[d] = sum;            }            int[] deg = new int[n];            for (int i = 0; i < n; ++i) {                int x = a[i];                ArrayList<Integer> pfs = new ArrayList<>();                while (x > 1) {                    int p = spf[x];                    pfs.add(p);                    while (x % p == 0) x /= p;                }                int parts = pfs.size();                int subsets = 1 << parts;                int cnt = 0;                for (int mask = 0; mask < subsets; ++mask) {                    int prod = 1;                    for (int j = 0; j < parts; ++j) if ((mask & (1 << j)) != 0) prod *= pfs.get(j);                    cnt += mu[prod] * f[prod];                }                deg[i] = cnt;            }            int maxDeg = -1, u = -1;            for (int i = 0; i < n; ++i) {                if (deg[i] > maxDeg) { maxDeg = deg[i]; u = i; }            }            if (maxDeg <= 0) {                out.append("0\n");                continue;            }            int bestV = -1, bestDeg = Integer.MAX_VALUE;            for (int j = 0; j < n; ++j) {                if (j == u) continue;                if (gcd(a[u], a[j]) == 1) {                    if (deg[j] < bestDeg) { bestDeg = deg[j]; bestV = j; }                }            }            if (bestV == -1) {                out.append("0\n");                continue;            }            boolean[] removed = new boolean[n];            removed[u] = true;            removed[bestV] = true;            for (int i = 0; i < n; ++i) {                if (removed[i]) continue;                if (gcd(a[i], a[u]) == 1) deg[i]--;                if (gcd(a[i], a[bestV]) == 1) deg[i]--;            }            int r = -1;            for (int i = 0; i < n; ++i) if (!removed[i] && deg[i] > 0) { r = i; break; }            if (r == -1) {                out.append("0\n");                continue;            }            int s = -1;            for (int j = 0; j < n; ++j) {                if (removed[j] || j == r) continue;                if (gcd(a[r], a[j]) == 1) { s = j; break; }            }            if (s == -1) {                out.append("0\n");            } else {                out.append((u+1)).append(' ').append((bestV+1)).append(' ').append((r+1)).append(' ').append((s+1)).append('\n');            }        }        System.out.print(out.toString());    }}