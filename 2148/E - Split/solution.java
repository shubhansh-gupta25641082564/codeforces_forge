import com.sun.security.jgss.GSSUtil; import java.io.*;import java.sql.Array;import java.sql.SQLOutput;import java.util.*; public class Main {    //public static boolean[] isPrime = new boolean[10000000];    public static int MOD = 1000000007;     public static void main(String[] args) throws IOException {        FastReader sc = new FastReader();        FastWriter out = new FastWriter();         int testcases = sc.nextInt();        while (testcases-- > 0) {                        int n = sc.nextInt();            int k = sc.nextInt();            int[] arr = new int[n];                        for (int i = 0; i < n; ++i) {                                arr[i] = sc.nextInt();                            }                        int[] nums = new int[n + 1];                        for (int i = 0 ; i < n ; i++) {                                int temp = arr[i];                nums[temp]++;                            }                        int[] needed = new int[n + 1];            boolean flag = true;                        for (int i = 1; i <= n; ++i) {                                if (nums[i] % k != 0) {                                         flag = false;                     break;                                     }                needed[i] = nums[i] / k;            }                        if (!flag) {                                System.out.println(0);                continue;                            }                        long ans = 0;                                                int[] arr2 = new int[n + 1];                        int num = 0;                        for (int i = 0; i < n; ++i) {                                while (num < n && arr2[arr[num]] < needed[arr[num]]) {                                        arr2[arr[num]]++;                    num++;                                    }                                ans = ans + num - i;                                if (num == i) {                                        num++;                                                        } else {                                        arr2[arr[i]]--;                                                        }            }                        System.out.println(ans);        }                   out.close();    }     static boolean recurse(int i, int n, boolean flag, int[] arr, int[] minHeight, int[] maxHeight, int[] leftBound, int[] rightBound) {        if (i > n) {            return true;        }         long xL, xR;         if (arr[i] == 0) {             xL = minHeight[i - 1];            xR = maxHeight[i - 1];        } else if (arr[i] == 1) {             xL = (long) minHeight[i - 1] + 1;            xR = (long) maxHeight[i - 1] + 1;        } else {             xL = minHeight[i - 1];            xR = (long) maxHeight[i - 1] + 1;        }         int nextMin = (int) Math.max(xL, leftBound[i]);        int nextMax = (int) Math.min(xR, rightBound[i]);         if (nextMin > nextMax) {             return false;        }        minHeight[i] = nextMin;        maxHeight[i] = nextMax;         return recurse(i + 1, n, flag, arr, minHeight, maxHeight, leftBound, rightBound);    }     static void getArray(int i, int h, int[] arr, int[] ans, int[] minHeight, int[] maxHeight) {        if (i == 0) return;        if (arr[i] != -1) {            ans[i] = arr[i];            getArray(i - 1, h - ans[i], arr, ans, minHeight, maxHeight);        } else {             if (h >= minHeight[i - 1] && h <= maxHeight[i - 1]) {                ans[i] = 0;                getArray(i - 1, h, arr, ans, minHeight, maxHeight);            } else {                ans[i] = 1;                getArray(i - 1, h - 1, arr, ans, minHeight, maxHeight);            }        }    }      public static void dfs(List<List<Integer>> adjList, int node, int[] visited, List<Integer> ans, Stack<Integer> stack1) {        visited[node] = 1;        ans.add(node);         for (int element : adjList.get(node)) {            if (visited[element] == 0) {                dfs(adjList, element, visited, ans, stack1);            }        }        stack1.push(node);     }     public static boolean isPrime(int n) {        if (n <= 1) return false;        if (n == 2 || n == 3) return true;        if (n % 2 == 0 || n % 3 == 0) return false;         for (int i = 5; i * i <= n; i += 6) {            if (n % i == 0 || n % (i + 2) == 0) return false;        }         return true;    }     public static boolean isPrime(long n) {        if (n <= 1) return false;        if (n == 2 || n == 3) return true;        if (n % 2 == 0 || n % 3 == 0) return false;         for (long i = 5; i * i <= n; i += 6) {            if (n % i == 0 || n % (i + 2) == 0) return false;        }         return true;    }      static List<Integer> getDivisors(int x) {        List<Integer> divs = new ArrayList<>();        for (int i = 1; (long) i * i <= x; i++) {            if (x % i == 0) {                divs.add(i);                if (i != x / i) {                    divs.add(x / i);                }            }        }        return divs;    }      public static int[] inputArray(FastReader sc, int n) {        int[] arr = new int[n];        for (int i = 0; i < n; i++) {            arr[i] = sc.nextInt();        }         return arr;    }      public static boolean isPowerOfTwo(long n) {        return (n & (n - 1)) == 0;    }     public static long flag(long[] arr, long mid, long sum, long k) {        int high = arr.length - 1;        long operations = 0;        while (high > 0) {            operations++;            sum = sum - (arr[high] - mid);            if (sum <= k) {                return operations;            }            high--;        }        if (sum <= k) {            return operations;        }        return -1;    }     public static class Pair<Pair> {        public final long first;        public final long second;         public Pair(long first, long second) {            this.first = first;            this.second = second;        } //        @Override//        public int compareTo(Pair other) {////            int cmp = Long.compare(other.first, this.first);//            if (cmp != 0) {//                return cmp;//            }//            return Integer.compare(this.second, other.second);//        } //        @Override//        public boolean equals(Object o) {//            if (this == o) return true;//            if (!(o instanceof Pair)) return false;//            Pair pair = (Pair) o;//            return first == pair.first && second == pair.second;//        } //        @Override//        public int hashCode() {//            return Objects.hash(first, second);//        }////        @Override//        public String toString() {//            return "(" + first + ", " + second + ")";//        }    }     public static class Tuple implements Comparable<Tuple> {         int first;        int second;        int third;         public Tuple(int first, int second, int third) {             this.first = first;            this.second = second;            this.third = third;         }         public int compareTo(Tuple other) {            return -Integer.compare(other.third, this.third);        }     }     public static void dfs(int[][] arr, boolean[][] visited, int row, int col) {        visited[row][col] = true;        for (int i = 0; i < 4; i++) {            int newRow = drow[i] + row;            int newCol = dcol[i] + col;            if (newRow >= 0 && newRow < arr.length && newCol >= 0 && newCol < arr[0].length &&                    !visited[newRow][newCol] && arr[newRow][newCol] == 1) {                dfs(arr, visited, newRow, newCol);            }        }    }     public static long[] inputArrayLong(FastReader sc, int length) {        long[] arr = new long[length];        for (int i = 0; i < length; i++) {            arr[i] = sc.nextLong();        }        return arr;    }     public static void printArray(long[] arr, FastWriter out) throws IOException {        for (long num : arr) {            out.print(num + " ");        }        out.println("");    }     public static void printArray(int[] arr, FastWriter out) throws IOException {        for (int num : arr) {            out.print(num + " ");        }        out.println("");    }     public static void printArray(boolean[] arr, FastWriter out) throws IOException {        for (boolean num : arr) {            out.print(num + " ");        }        out.println("");    }     public static void printArray(double[] arr, FastWriter out) throws IOException {        for (double num : arr) {            out.print(num + " ");        }        out.println("");    }     public static class FastReader {        BufferedReader br;        StringTokenizer st;         public FastReader() {            br = new BufferedReader(new InputStreamReader(System.in));        }         String next() {            while (st == null || !st.hasMoreTokens()) {                try {                    st = new StringTokenizer(br.readLine());                } catch (IOException e) {                    e.printStackTrace();                }            }            return st.nextToken();        }         int nextInt() {            return Integer.parseInt(next());        }         long nextLong() {            return Long.parseLong(next());        }    }     public static class FastWriter {        BufferedWriter bwr;         public FastWriter() {            bwr = new BufferedWriter(new OutputStreamWriter(System.out));        }         public void print(Object o) throws IOException {            bwr.append(o.toString());        }         public void println(Object o) throws IOException {            bwr.append(o.toString()).append("\n");        }         public void close() throws IOException {            bwr.close();        }    } //    public static void Seive() {//        int n = isPrime.length - 1;//        for (int i = 0; i <= n; i++) {//            isPrime[i] = true;//        }//        isPrime[0] = false;//        isPrime[1] = false;//        for (int i = 2; i * i <= n; i++) {//            if (isPrime[i]) {//                for (int j = i * i; j <= n; j += i) {//                    if (j < 0) {//                        break;//                    }//                    isPrime[j] = false;//                }//            }//        }////        for (int i = 2; i <= n; i++) {////            if (isPrime[i]) {////                System.out.println(i);////            }////        }//    }     public static String encryption(String s) {        StringBuilder sb = new StringBuilder();        int len = s.length();        int row = (int) Math.sqrt(len);        int col = (int) Math.ceil(Math.sqrt(len));        if (row * col < len) {            row = Math.max(row, col);            col = Math.max(row, col);        }        for (int i = 1; i <= s.length(); i++) {            if (i % row == 0) {                sb.append(" ");            }            sb.append(s.charAt(i - 1));        }        return sb.toString();    }     public static class SubarrayResult {        public long maxSum;        public int startIndex;        public int endIndex;         public SubarrayResult(long maxSum, int startIndex, int endIndex) {            this.maxSum = maxSum;            this.startIndex = startIndex;            this.endIndex = endIndex;        }    }     public static SubarrayResult maxSubarray(long[] arr) {        if (arr == null || arr.length == 0) {            return new SubarrayResult(0, -1, -1);        }        long maxSoFar = arr[0];        long maxEndingHere = arr[0];        int start = 0;        int tempStart = 0;        int end = 0;         for (int i = 1; i < arr.length; i++) {            if (arr[i] > maxEndingHere + arr[i]) {                maxEndingHere = arr[i];                tempStart = i;            } else {                maxEndingHere += arr[i];            }             if (maxEndingHere > maxSoFar) {                maxSoFar = maxEndingHere;                start = tempStart;                end = i;            }        }        return new SubarrayResult(maxSoFar, start, end);    }     public static ArrayList<Integer> getPrimeFactors(int n) {        ArrayList<Integer> primeFactors = new ArrayList<>();         while (n % 2 == 0) {            primeFactors.add(2);            n /= 2;        }        for (int i = 3; i <= Math.sqrt(n); i += 2) {            while (n % i == 0) {                primeFactors.add(i);                n /= i;            }        }         if (n > 2) {            primeFactors.add(n);        }         return primeFactors;    }     public static long gcd(long arr, long b) {        while (b != 0) {            long temp = b;            b = arr % b;            arr = temp;        }        return arr;    }     public static long gcd(int arr, int b) {        while (b != 0) {            int temp = b;            b = arr % b;            arr = temp;        }        return arr;    }     public static long lcm(int arr, int b) {        if (arr == 0 || b == 0) return 0;        return Math.abs(arr / gcd(arr, b) * b);    }     public static long lcm(long arr, long b) {        if (arr == 0 || b == 0) return 0;        return Math.abs(arr / gcd(arr, b) * b);    }     static int[] drow = {-1, 1, 0, 0};    static int[] dcol = {0, 0, -1, 1};  }