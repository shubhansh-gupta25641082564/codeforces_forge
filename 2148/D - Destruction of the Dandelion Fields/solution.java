//TIP To <b>Run</b> code, press <shortcut actionId="Run"/> or// click the <icon src="AllIcons.Actions.Execute"/> icon in the gutter. import java.lang.*;import java.io.*;import java.util.*; public class Main {    static int mod = 1000000007;    static PrintWriter out;    static Scanner sc;     /**     * Finds the index of the first element in the sorted list that is not less than the target value.     *     * @param sortedList A sorted list of integers.     * @param target     The target value to find the lower bound for.     * @return The index of the first element that is not less than the target value.     */    public static int lowerBound(long[] sortedList, long target) {        int lo = 0;        int hi = sortedList.length;        while (lo < hi) {            int mid = (lo + hi) / 2;            if (sortedList[mid] < target) {                lo = mid + 1;            } else {                hi = mid;            }        }        return lo < sortedList.length ? lo : -1;    }     /**     * Finds the index of the first element in the sorted list that is greater than the target value.     *     * @param sortedList A sorted list of integers.     * @param target     The target value to find the upper bound for.     * @return The index of the first element that is greater than the target value.     */    public static int upperBound(long[] sortedList, long target) {        int lo = 0;        int hi = sortedList.length;        while (lo < hi) {            int mid = (lo + hi) / 2;            if ((int) sortedList[mid] <= target) {                lo = mid + 1;            } else {                hi = mid;            }        }        return lo;    }     public static long mod_sub(long a, long b, long m) {        a = a % m;        b = b % m;        return (((a - b) % m) + m) % m;    }     public static long powerMod(long x, long y, long p) {        long res = 1;        x = x % p;        if (x == 0)            return 0;        while (y > 0) {            if ((y & 1) > 0)                res = (res * x) % p;            y = y >> 1;            x = (x * x) % p;        }        return res;    }     public static long power(long a, long b) {        long result = 1;        while (b > 0) {            if ((b & 1) == 1) {                result *= a;            }            a *= a;            b >>= 1;        }        return result;    }     private static boolean isPalindrome(String s) {        StringBuilder str1 = new StringBuilder(s);        str1.reverse();         return s.contentEquals(str1);    }     static int sumOfSubArrayProd(int[] arr, int l, int r, int m) {        int ans = 0;        int res = 0;        int sum = 0;        for (int i = r - 1; i >= l; i--) {            int incr = ((arr[i] % m) * ((1 + res) % m)) % m;            ans = (ans % m + incr % m) % m;            res = (incr % m);            sum += arr[i];        }        return (ans % m - sum % m) % m;    }     public static void println(int[] a) {        for (int i : a) out.print(i + " ");        out.println();    }     public static boolean isPrime(double n) {        if (n <= 1.0)            return false;        if (n == 2.0 || n == 3.0)            return true;         if (n % 2.0 == 0.0 || n % 3.0 == 0.0)            return false;         for (double i = 5.0; i <= Math.sqrt(n); i = i + 6.0)            if (n % i == 0.0 || n % (i + 2.0) == 0.0)                return false;         return true;    }     static long getLargestDivisor(long number) {        long i;        for (i = 2; i <= Math.sqrt(number); i++) {            if (number % i == 0) {                return number / i;            }        }        return 1L;    }     static long gcd(long a, long b) {        if (b == 0)            return a;        return gcd(b, a % b);    }     static int E() {        return 9;    }     public static int lengthOfLIS(ArrayList<Integer> nums) {        if (nums == null || nums.isEmpty()) {            return 0;        }         int n = nums.size();        int[] dp = new int[n];        Arrays.fill(dp, 1);         for (int i = 1; i < n; ++i) {            for (int j = 0; j < i; ++j) {                if (nums.get(i) > nums.get(j)) {                    dp[i] = Math.max(dp[i], dp[j] + 1);                }            }        }         int maxLength = Arrays.stream(dp).max().orElse(0);        return maxLength;    }     static ArrayList<ArrayList<Integer>> allPaths = new ArrayList<>();     public static void getAllPaths(int s, int d, int n, ArrayList<ArrayList<Integer>> graph) {        boolean[] isVisited = new boolean[n];        ArrayList<Integer> pathList = new ArrayList<>();        pathList.add(s);        getAll(s, d, isVisited, pathList, graph);    }     private static void getAll(Integer u, Integer d, boolean[] isVisited, ArrayList<Integer> localPathList, ArrayList<ArrayList<Integer>> graph) {         if (u.equals(d)) {            allPaths.add(new ArrayList<>(localPathList));            return;        }         isVisited[u] = true;         for (Integer i : graph.get(u)) {            if (!isVisited[i]) {                localPathList.add(i);                getAll(i, d, isVisited, localPathList, graph);                localPathList.remove(i);            }        }         isVisited[u] = false;    }     private int dijkstra(int n, ArrayList<ArrayList<ArrayList<Integer>>> graph) {        int[] dist = new int[n];        Arrays.fill(dist, Integer.MAX_VALUE);        dist[0] = 0;        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));        pq.offer(new int[]{0, 0});         while (!pq.isEmpty()) {            int[] ele = pq.poll();            int cd = ele[0], node = ele[1];            if (node == n - 1) return dist[n - 1];            if (cd > dist[node]) continue;            for (ArrayList<Integer> neighbor : graph.get(node)) {                int nbr = neighbor.get(0), wt = neighbor.get(1);                if (cd + wt < dist[nbr]) {                    dist[nbr] = cd + wt;                    pq.offer(new int[]{cd + wt, nbr});                }            }        }        return dist[n - 1];    }     static ArrayList<Integer> getAllDivisors(int n) {        ArrayList<Integer> arr = new ArrayList<>();        for (int i = 1; i <= Math.sqrt(n); i++) {            if (n % i == 0) {                if (n / i == i) {                    arr.add(i);                } else {                    arr.add(i);                    arr.add(n / i);                }            }        }        return arr;    }      public static void yes() {        out.println("Yes");    }     public static void no() {        out.println("No");    }     public static class Triple {        private Long first;        private Long second;        private Long third;         public Triple(Long first, Long second, Long third) {            this.first = first;            this.second = second;            this.third = third;        }         public Long getFirst() {            return first;        }         public void setFirst(Long first) {            this.first = first;        }         public Long getSecond() {            return second;        }         public void setSecond(Long second) {            this.second = second;        }         public Long getThird() {            return third;        }         public void setThird(Long third) {            this.third = third;        }         @Override        public boolean equals(Object o) {            if (this == o) return true;            if (o == null || getClass() != o.getClass()) return false;             Triple triple = (Triple) o;             if (!Objects.equals(first, triple.first)) return false;            if (!Objects.equals(second, triple.second)) return false;            return Objects.equals(third, triple.third);        }         @Override        public int hashCode() {            int result = first != null ? first.hashCode() : 0;            result = 31 * result + (second != null ? second.hashCode() : 0);            result = 31 * result + (third != null ? third.hashCode() : 0);            return result;        }    }     public static void dfs(ArrayList<ArrayList<Integer>> graph, int node, int par, int dep) {        for (int nei : graph.get(node)) {            if (nei != par) {                dfs(graph, nei, node, dep + 1);            }        }        out.print(node + " ");    }     static int greatestDivisor(int number) {        int i;        for (i = 2; i <= Math.sqrt(number); i++) {            if (number % i == 0) {                return number / i;            }        }        return 1;    }     static boolean isPowerOfTwo(int n) {        if (n == 0)            return false;         return (int) (Math.ceil((Math.log(n) / Math.log(2))))                == (int) (Math.floor(                ((Math.log(n) / Math.log(2)))));    }     static <K, V extends Comparable<? super V>>    SortedSet<Map.Entry<K, V>> entriesSortedByValues(Map<K, V> map) {        SortedSet<Map.Entry<K, V>> sortedEntries = new TreeSet<Map.Entry<K, V>>(                new Comparator<Map.Entry<K, V>>() {                    @Override                    public int compare(Map.Entry<K, V> e1, Map.Entry<K, V> e2) {                        int res = e1.getValue().compareTo(e2.getValue());                        return res != 0 ? res : 1;                    }                }        );        sortedEntries.addAll(map.entrySet());        return sortedEntries;    }     static int getInvCount(int[] arr) {        int n = arr.length;        int inv_count = 0;         for (int i = 0; i < n - 1; i++) {            for (int j = i + 1; j < n; j++) {                // If the current element is greater than the next,                // increment the count                if (arr[i] > arr[j])                    inv_count++;            }        }        return inv_count;    }      public static int countInversions(char[] arr) {        int count = 0, res = 0;        for (int i = arr.length - 1; i >= 0; i--) {            if (arr[i] == '1') {                res += count;            } else {                count++;            }        }        return res;    }     static long getKthBit(long n, long k) {        return (n & (1L << (k))) >> (k);    }     static boolean graphColoringUtil(boolean[][] graph, int m, int[] color, int v, int n) {        if (v == n)            return true;         for (int c = 1; c <= m; c++) {            if (isSafe(v, graph, color, c, n)) {                color[v] = c;                if (graphColoringUtil(graph, m, color, v + 1, n))                    return true;                color[v] = 0;            }        }         return false;    }     static boolean isSafe(int v, boolean[][] graph, int[] color, int c, int n) {        for (int i = 0; i < n; i++)            if (graph[v][i] && c == color[i])                return false;        return true;    }     static long moduloMultiplication(long a, long b, long mod) {        long res = 0;        a %= mod;         while (b > 0) {             if ((b & 1) != 0)                res = (res + a) % mod;             a = (2 * a) % mod;            b >>= 1;        }        return res;    }     static boolean isPerfectSquare(long number) {        double sqrt = Math.sqrt(number);        return ((sqrt - Math.floor(sqrt)) == 0);    }     static long x, y;     static long gcdExtended(long a, long b) {         if (a == 0) {            x = 0;            y = 1;            return b;        }         long gcd = gcdExtended(b % a, a);        long x1 = x;        long y1 = y;        x = y1 - (b / a) * x1;        y = x1;         return gcd;    }      private long ncr(int n, int r, long[] fact, long[] invFact, int MOD) {        if (r > n || r < 0) return 0;        return fact[n] * invFact[r] % MOD * invFact[n - r] % MOD;    }     private void getFactorials(long[] fact, long[] invFact, int n, int MOD) {        fact[0] = invFact[0] = 1;        for (int i = 1; i <= n; i++) {            fact[i] = fact[i - 1] * i % MOD;        }        invFact[n] = powerMod(fact[n], MOD - 2, MOD); // Fermat's little theorem        for (int i = n - 1; i >= 1; i--) {            invFact[i] = invFact[i + 1] * (i + 1) % MOD;        }    }     static Set<Integer> getAllFactorsVer3(int n) {        Set<Integer> factors = new HashSet<>();        int step = n % 2 == 0 ? 1 : 2;        for (int i = 1; i <= Math.sqrt(n); i += step) {            if (n % i == 0) {                factors.add(i);                factors.add(n / i);            }        }        return factors;    }     static long modInverse(long a, long m) {        long g = gcdExtended(a, m);        if (g != 1)            return -1;        return (x % m + m) % m;    }     static long modDivide(long a, long b, long m) {         a = a % m;        long inv = modInverse(b, m);        if (inv == -1)            return 0;        else            return (inv * a) % m;    }     static long nCr(long n, long r, long p) {        if (r > n)            return 0;        if (r > n - r)            r = n - r;        long x = 1;        for (long i = 1L; i <= r; i++) {            x = moduloMultiplication(x, (n + 1L - i), p);            x = modDivide(x, i, p);        }        return x;    }     private static int[] reverseArr(int[] a) {        int[] rev = new int[a.length];        for (int i = 0; i < a.length; i++) {            rev[i] = a[a.length - i - 1];        }        return rev;    }     private static void printArr(int[] p) {        for (int i : p) {            out.print(i + " ");        }        out.println();    }     public static boolean overlap(int x1, int y1, int x2, int y2) {        return x1 <= y2 && y1 >= x2;    }     static int lds(int arr[], int n) {        int[] lds = new int[n];        int i, j, max = 0;        for (i = 0; i < n; i++)            lds[i] = 1;        for (i = 1; i < n; i++) {            for (j = 0; j < i; j++) {                if (arr[i] < arr[j] && lds[i] < lds[j] + 1) {                    lds[i] = lds[j] + 1;                }            }        }        for (i = 0; i < n; i++)            if (max < lds[i])                max = lds[i];        return max;    }     static int lis(int arr[], int n) {        int[] lis = new int[n];        Arrays.fill(lis, 1);        for (int i = 1; i < n; i++)            for (int prev = 0; prev < i; prev++)                if (arr[i] > arr[prev] && lis[i] < lis[prev] + 1)                    lis[i] = lis[prev] + 1;        int max = 1;        for (int i = 0; i < n; i++)            max = Math.max(max, lis[i]);         return max;    }     public static int[] findMex(int[] arr) {        int[] kk = new int[2];        Arrays.fill(kk, -1);        int mex = 0, f = 0;        for (int j = 0; j < arr.length; j++) {            if (arr[j] == mex) {                mex++;            } else {                if (f == 1) {                    kk[1] = mex;                    break;                }                f = 1;                kk[0] = mex;                mex++;                j--;            }        }        if (kk[0] == -1) {            kk[0] = arr.length;            kk[1] = arr.length + 1;        } else if (kk[1] == -1) {            kk[1] = mex;        }        return kk;    }      private static int findMax(int[] count) {        int max = Integer.MIN_VALUE;        for (int i : count) {            max = Math.max(max, i);        }        return max;    }     public static boolean next_permutation(int[] p) {        for (int a = p.length - 2; a >= 0; --a)            if (p[a] < p[a + 1])                for (int b = p.length - 1; ; --b)                    if (p[b] > p[a]) {                        int t = p[a];                        p[a] = p[b];                        p[b] = t;                        for (++a, b = p.length - 1; a < b; ++a, --b) {                            t = p[a];                            p[a] = p[b];                            p[b] = t;                        }                        return true;                    }        return false;    }     static long largestPower(long n, long p) {        long x = 0;         while (n > 0) {            n /= p;            x += n;        }        return x;    }     static long modFact(int n, int p) {        if (n >= p) {            return 0;        }         long res = 1;         boolean isPrime[] = new boolean[n + 1];        Arrays.fill(isPrime, true);        for (int i = 2; i * i <= n; i++) {            if (isPrime[i]) {                for (int j = 2 * i; j <= n; j += i) {                    isPrime[j] = false;                }            }        }         for (int i = 2; i <= n; i++) {            if (isPrime[i]) {                long k = largestPower(n, i);                 res = (res * powerMod(i, k, p)) % p;            }        }        return res;    }     public static int[][] merge(int[][] intervals) {        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));        LinkedList<int[]> merged = new LinkedList<>();        for (int[] interval : intervals) {            if (merged.isEmpty() || merged.getLast()[1] < interval[0]) {                merged.add(interval);            } else {                merged.getLast()[1] = Math.max(merged.getLast()[1], interval[1]);            }        }        return merged.toArray(new int[merged.size()][]);    }     public static HashMap<Integer, Integer> sortByValue(HashMap<Integer, Integer> hm) {        List<Map.Entry<Integer, Integer>> list =                new LinkedList<>(hm.entrySet());         list.sort(Map.Entry.comparingByValue());         HashMap<Integer, Integer> temp = new LinkedHashMap<>();        for (Map.Entry<Integer, Integer> aa : list) {            temp.put(aa.getKey(), aa.getValue());        }        return temp;    }     static int MAX = 100, n;     static int[] store = new int[MAX];     static int[][] graph = new int[MAX][MAX];     static int[] d = new int[MAX];     static boolean is_clique(int b) {         for (int i = 1; i < b; i++) {            for (int j = i + 1; j < b; j++)                 // If any edge is missing                if (graph[store[i]][store[j]] == 0)                    return false;        }        return true;    }     static int maxCliques(int i, int l) {        int max_ = 0;         for (int j = i + 1; j <= n; j++) {             store[l] = j;            if (is_clique(l + 1)) {                 max_ = Math.max(max_, l);                max_ = Math.max(max_, maxCliques(j, l + 1));            }        }        return max_;    }     public static int distinctSubstring(String str) {         // Put all distinct substring in a HashSet        Set<String> result = new HashSet<String>();         // List All Substrings        for (int i = 0; i <= str.length(); i++) {            for (int j = i + 1; j <= str.length(); j++) {                 // Add each su                // bstring in Set                result.add(str.substring(i, j));            }        }         // Return the HashSet        return result.size();    }     public static boolean isSorted(long[] a) {        for (int i = 0; i < a.length - 1; i++) {            if (a[i] > a[i + 1]) {                return false;            }        }        return true;    }     public static int[] cyclicMinArray(int[] arr) {        int n = arr.length;        int[] doubled = new int[2 * n];        System.arraycopy(arr, 0, doubled, 0, n);        System.arraycopy(arr, 0, doubled, n, n);         int[] f = new int[2 * n];        Arrays.fill(f, -1);        int k = 0;         for (int j = 1; j < 2 * n; j++) {            int i = f[j - k - 1];            while (i != -1 && doubled[j] != doubled[k + i + 1]) {                if (doubled[j] < doubled[k + i + 1]) k = j - i - 1;                i = f[i];            }            if (doubled[j] != doubled[k + i + 1]) {                if (doubled[j] < doubled[k]) k = j;                f[j - k] = -1;            } else f[j - k] = i + 1;        }         int[] result = new int[n];        System.arraycopy(doubled, k, result, 0, n);        return result;    }     public static int findDistanceBwPointsSq(int x, int y, int x2, int y2) {        return (x - x2) * (x - x2) + (y - y2) * (y - y2);    }     // LCM of two numbers    static long lcm(long u, long v) {        return (u / gcd(u, v)) * v;    }     public static class Pair<F, S> {        public final F first;        public final S second;         public Pair(F first, S second) {            this.first = first;            this.second = second;        }         @Override        public boolean equals(Object o) {            if (!(o instanceof Pair)) return false;            Pair<?, ?> p = (Pair<?, ?>) o;            return java.util.Objects.equals(first, p.first) &&                    java.util.Objects.equals(second, p.second);        }         @Override        public int hashCode() {            return java.util.Objects.hash(first, second);        }         @Override        public String toString() {            return "Pair{" + first + ", " + second + '}';        }    }     public static boolean hasCycleDirected(ArrayList<ArrayList<Integer>> adj) {        int n = adj.size();        boolean[] visited = new boolean[n];        boolean[] recStack = new boolean[n];         for (int i = 0; i < n; i++) {            if (!visited[i] && dfsDirected(i, adj, visited, recStack)) {                return true;            }        }        return false;    }     private static boolean dfsDirected(int node, ArrayList<ArrayList<Integer>> adj,                                       boolean[] visited, boolean[] recStack) {        visited[node] = true;        recStack[node] = true;         for (int neighbor : adj.get(node)) {            if (!visited[neighbor] && dfsDirected(neighbor, adj, visited, recStack))                return true;            else if (recStack[neighbor])                return true;        }         recStack[node] = false;        return false;    }     public static boolean hasCycleUndirected(ArrayList<ArrayList<Integer>> adj) {        int n = adj.size();        boolean[] visited = new boolean[n];         for (int i = 0; i < n; i++) {            if (!visited[i] && dfs(i, -1, adj, visited)) {                return true;            }        }        return false;    }     private static boolean dfs(int node, int parent, ArrayList<ArrayList<Integer>> adj, boolean[] visited) {        visited[node] = true;         for (int neighbor : adj.get(node)) {            if (!visited[neighbor]) {                if (dfs(neighbor, node, adj, visited))                    return true;            } else if (neighbor != parent) {                // Visited neighbor that's not the parent → cycle found                return true;            }        }        return false;    }     public static void main(String[] args) throws IOException {        Scanner sc = new Scanner(System.in);        out = new PrintWriter(System.out);        int tes = sc.nextInt();        while (tes-- != 0) {            int n = sc.nextInt();            ArrayList<Integer> odd = new ArrayList<>();            long ans = 0;            for (int i = 0; i < n; i++) {                int a = sc.nextInt();                if (a % 2 == 0) {                    ans += a;                } else {                    odd.add(a);                }            }            if (odd.isEmpty()) {                out.println(0);                continue;            }            Collections.sort(odd);            int i = 0, j = odd.size() - 1;            while (i <= j) {                if (i == j) {                    ans += odd.get(j);                    break;                }                ans += odd.get(j);                i++;                j--;            }            out.println(ans);         }         sc.close();        out.close();    } }