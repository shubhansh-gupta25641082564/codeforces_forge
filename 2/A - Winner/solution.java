import java.util.*;import java.io.*; // हर हर महादेव public class Main {     public static void main(String[] args) throws Exception {        ContestScanner sc = new ContestScanner();        ContestPrinter out = new ContestPrinter(System.out);         // sc = new ContestScanner(new File("input.txt"));        // out = new FastWriter("output.txt");         boolean debug = args.length > 0 && args[0].equals("-DEBUG");        Thread t = new Thread(null, new ActualSolution(sc, out, debug), "actual_solution", 256 << 20);        t.start();        t.join();        out.flush();    } } class ContestScanner {    private final java.io.InputStream in;    private final byte[] buffer = new byte[1024];    private int ptr = 0;    private int buflen = 0;     private static final long LONG_MAX_TENTHS = 922337203685477580L;    private static final int LONG_MAX_LAST_DIGIT = 7;    private static final int LONG_MIN_LAST_DIGIT = 8;     public ContestScanner(java.io.InputStream in) {        this.in = in;    }     public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));    }     public ContestScanner() {        this(System.in);    }     private boolean hasNextByte() {        if (ptr < buflen) {            return true;        } else {            ptr = 0;            try {                buflen = in.read(buffer);            } catch (java.io.IOException e) {                e.printStackTrace();            }            if (buflen <= 0) {                return false;            }        }        return true;    }     private int readByte() {        if (hasNextByte())            return buffer[ptr++];        else            return -1;    }     private static boolean isPrintableChar(int c) {        return 33 <= c && c <= 126;    }     public boolean hasNext() {        while (hasNextByte() && !isPrintableChar(buffer[ptr]))            ptr++;        return hasNextByte();    }     public String next() {        if (!hasNext())            throw new java.util.NoSuchElementException();        StringBuilder sb = new StringBuilder();        int b = readByte();        while (isPrintableChar(b)) {            sb.appendCodePoint(b);            b = readByte();        }        return sb.toString();    }     public long nextLong() {        if (!hasNext())            throw new java.util.NoSuchElementException();        long n = 0;        boolean minus = false;        int b = readByte();        if (b == '-') {            minus = true;            b = readByte();        }        if (b < '0' || '9' < b) {            throw new NumberFormatException();        }        while (true) {            if ('0' <= b && b <= '9') {                int digit = b - '0';                if (n >= LONG_MAX_TENTHS) {                    if (n == LONG_MAX_TENTHS) {                        if (minus) {                            if (digit <= LONG_MIN_LAST_DIGIT) {                                n = -n * 10 - digit;                                b = readByte();                                if (!isPrintableChar(b)) {                                    return n;                                } else if (b < '0' || '9' < b) {                                    throw new NumberFormatException(                                            String.format("%d%s... is not number", n, Character.toString(b)));                                }                            }                        } else {                            if (digit <= LONG_MAX_LAST_DIGIT) {                                n = n * 10 + digit;                                b = readByte();                                if (!isPrintableChar(b)) {                                    return n;                                } else if (b < '0' || '9' < b) {                                    throw new NumberFormatException(                                            String.format("%d%s... is not number", n, Character.toString(b)));                                }                            }                        }                    }                    throw new ArithmeticException(                            String.format("%s%d%d... overflows long.", minus ? "-" : "", n, digit));                }                n = n * 10 + digit;            } else if (b == -1 || !isPrintableChar(b)) {                return minus ? -n : n;            } else {                throw new NumberFormatException();            }            b = readByte();        }    }     public int nextInt() {        long nl = nextLong();        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)            throw new NumberFormatException();        return (int) nl;    }     public double nextDouble() {        return Double.parseDouble(next());    }     public long[] nextLongArray(int length) {        long[] array = new long[length];        for (int i = 0; i < length; i++)            array[i] = this.nextLong();        return array;    }     public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map) {        long[] array = new long[length];        for (int i = 0; i < length; i++)            array[i] = map.applyAsLong(this.nextLong());        return array;    }     public int[] nextIntArray(int length) {        int[] array = new int[length];        for (int i = 0; i < length; i++)            array[i] = this.nextInt();        return array;    }     public int[] nextIntArray(int length, java.util.function.IntUnaryOperator map) {        int[] array = new int[length];        for (int i = 0; i < length; i++)            array[i] = map.applyAsInt(this.nextInt());        return array;    }     public double[] nextDoubleArray(int length) {        double[] array = new double[length];        for (int i = 0; i < length; i++)            array[i] = this.nextDouble();        return array;    }     public double[] nextDoubleArray(int length, java.util.function.DoubleUnaryOperator map) {        double[] array = new double[length];        for (int i = 0; i < length; i++)            array[i] = map.applyAsDouble(this.nextDouble());        return array;    }     public long[][] nextLongMatrix(int height, int width) {        long[][] mat = new long[height][width];        for (int h = 0; h < height; h++)            for (int w = 0; w < width; w++) {                mat[h][w] = this.nextLong();            }        return mat;    }     public int[][] nextIntMatrix(int height, int width) {        int[][] mat = new int[height][width];        for (int h = 0; h < height; h++)            for (int w = 0; w < width; w++) {                mat[h][w] = this.nextInt();            }        return mat;    }     public double[][] nextDoubleMatrix(int height, int width) {        double[][] mat = new double[height][width];        for (int h = 0; h < height; h++)            for (int w = 0; w < width; w++) {                mat[h][w] = this.nextDouble();            }        return mat;    }     public char[][] nextCharMatrix(int height, int width) {        char[][] mat = new char[height][width];        for (int h = 0; h < height; h++) {            String s = this.next();            for (int w = 0; w < width; w++) {                mat[h][w] = s.charAt(w);            }        }        return mat;    }} class ContestPrinter extends java.io.PrintWriter {    public ContestPrinter(java.io.PrintStream stream) {        super(stream);    }     public ContestPrinter(java.io.File file) throws java.io.FileNotFoundException {        super(new java.io.PrintStream(file));    }     public ContestPrinter() {        super(System.out);    }     private static String dtos(double x, int n) {        StringBuilder sb = new StringBuilder();        if (x < 0) {            sb.append('-');            x = -x;        }        x += Math.pow(10, -n) / 2;        sb.append((long) x);        sb.append(".");        x -= (long) x;        for (int i = 0; i < n; i++) {            x *= 10;            sb.append((int) x);            x -= (int) x;        }        return sb.toString();    }     @Override    public void print(float f) {        super.print(dtos(f, 20));    }     @Override    public void println(float f) {        super.println(dtos(f, 20));    }     @Override    public void print(double d) {        super.print(dtos(d, 20));    }     @Override    public void println(double d) {        super.println(dtos(d, 20));    }     public void printArray(int[] array, String separator) {        int n = array.length;        if (n == 0) {            super.println();            return;        }        for (int i = 0; i < n - 1; i++) {            super.print(array[i]);            super.print(separator);        }        super.println(array[n - 1]);    }     public void printArray(int[] array) {        this.printArray(array, " ");    }     public void printArray(int[] array, String separator, java.util.function.IntUnaryOperator map) {        int n = array.length;        if (n == 0) {            super.println();            return;        }        for (int i = 0; i < n - 1; i++) {            super.print(map.applyAsInt(array[i]));            super.print(separator);        }        super.println(map.applyAsInt(array[n - 1]));    }     public void printArray(int[] array, java.util.function.IntUnaryOperator map) {        this.printArray(array, " ", map);    }     public void printArray(long[] array, String separator) {        int n = array.length;        if (n == 0) {            super.println();            return;        }        for (int i = 0; i < n - 1; i++) {            super.print(array[i]);            super.print(separator);        }        super.println(array[n - 1]);    }     public void printArray(long[] array) {        this.printArray(array, " ");    }     public void printArray(long[] array, String separator, java.util.function.LongUnaryOperator map) {        int n = array.length;        if (n == 0) {            super.println();            return;        }        for (int i = 0; i < n - 1; i++) {            super.print(map.applyAsLong(array[i]));            super.print(separator);        }        super.println(map.applyAsLong(array[n - 1]));    }     public void printArray(long[] array, java.util.function.LongUnaryOperator map) {        this.printArray(array, " ", map);    }     public <T> void printArray(T[] array, String separator) {        int n = array.length;        if (n == 0) {            super.println();            return;        }        for (int i = 0; i < n - 1; i++) {            super.print(array[i]);            super.print(separator);        }        super.println(array[n - 1]);    }     public <T> void printArray(T[] array) {        this.printArray(array, " ");    }     public <T> void printArray(T[] array, String separator, java.util.function.UnaryOperator<T> map) {        int n = array.length;        if (n == 0) {            super.println();            return;        }        for (int i = 0; i < n - 1; i++) {            super.print(map.apply(array[i]));            super.print(separator);        }        super.println(map.apply(array[n - 1]));    }     public <T> void printArray(T[] array, java.util.function.UnaryOperator<T> map) {        this.printArray(array, " ", map);    }} class ActualSolution implements Runnable {     boolean debug;    ContestScanner sc;    ContestPrinter out;     public ActualSolution(ContestScanner sc, ContestPrinter out, boolean debug) {        this.sc = sc;        this.out = out;        this.debug = debug;         if (debug) {            try {                System.setErr(new PrintStream(new FileOutputStream("D:\\Codes\\CPRelatedFiles\\error.txt")));            } catch (FileNotFoundException e) {                throw new RuntimeException(e);            }        }    }     @SuppressWarnings("unchecked")    <T> String debugIt(T t) {        if (t == null)            return "null";        try {            return debugIt((Iterable<T>) t);        } catch (ClassCastException e) {            if (t instanceof int[])                return Arrays.toString((int[]) t);            else if (t instanceof long[])                return Arrays.toString((long[]) t);            else if (t instanceof char[])                return Arrays.toString((char[]) t);            else if (t instanceof float[])                return Arrays.toString((float[]) t);            else if (t instanceof double[])                return Arrays.toString((double[]) t);            else if (t instanceof boolean[])                return Arrays.toString((boolean[]) t);            try {                return debugIt((Object[]) t);            } catch (ClassCastException e1) {                return t.toString();            }        }    }     <T> String debugIt(T[] arr) {        StringBuilder ret = new StringBuilder();        ret.append("[");        boolean first = true;        for (T t : arr) {            if (!first) {                ret.append(", ");            }            first = false;            ret.append(debugIt(t));        }        ret.append("]");        return ret.toString();    }     <T> String debugIt(Iterable<T> it) {        StringBuilder ret = new StringBuilder();        ret.append("[");        boolean first = true;        for (T t : it) {            if (!first) {                ret.append(", ");            }            first = false;            ret.append(debugIt(t));        }        ret.append("]");        return ret.toString();    }     void debug(Object... obj) {        if (!debug)            return;         System.err.print("#" + Thread.currentThread().getStackTrace()[2].getLineNumber() + ": ");        for (Object x : obj) {            System.err.print(debugIt(x));            System.err.print(" ");        }        System.err.println();        System.err.flush();    }     @Override    public void run() {        int testCases = 1;        for (int testCase = 1; testCase <= testCases; testCase++) {            debug("......");            debug("Test case ", testCase);             // out.print("Case #");            // out.print(testCase);            // out.print(": ");             solve();         }    }     public static void merge(long arr[], int l, int m, int r) {        int n1 = m - l + 1;        int n2 = r - m;         // Create temporary arrays        long L[] = new long[n1];        long R[] = new long[n2];         // Copy data to temporary arrays L[] and R[]        System.arraycopy(arr, l, L, 0, n1);        System.arraycopy(arr, m + 1, R, 0, n2);         // Merge the temporary arrays back into arr[l..r]        int i = 0, j = 0;        int k = l;        while (i < n1 && j < n2) {            if (L[i] <= R[j]) {                arr[k] = L[i];                i++;            } else {                arr[k] = R[j];                j++;            }            k++;        }         // Copy the remaining elements of L[], if there are any        while (i < n1) {            arr[k] = L[i];            i++;            k++;        }         // Copy the remaining elements of R[], if there are any        while (j < n2) {            arr[k] = R[j];            j++;            k++;        }    }     // Main function that sorts arr[l..r] using merge()    public static void mergeSort(long arr[], int l, int r) {        if (l < r) {            // Find the middle point            int m = (l + r) / 2;             // Sort first and second halves            mergeSort(arr, l, m);            mergeSort(arr, m + 1, r);             // Merge the sorted halves            merge(arr, l, m, r);        }    }     int gcd(int num1, int num2) {        int min = Math.min(num1, num2);        int index = 0;        for (int i = min; i >= 1; i--) {            if (num1 % i == 0 && num2 % i == 0) {                index = i;                break;            }        }        return index;    }     boolean issorted(int arr[]) {        for (int i = 0; i < arr.length - 1; i++) {            if (arr[i + 1] < arr[i]) {                return false;            }        }        return true;    }     // code of longestpalindrome check starts here    String longestPalindrome(String s) {        int n = s.length();        if (n <= 1) {            return s;        }         boolean[][] isPalindrome = new boolean[n][n];        int start = 0, maxLen = 1;         // All substrings of length 1 are palindromes        for (int i = 0; i < n; i++) {            isPalindrome[i][i] = true;        }         // Check substrings of length 2        for (int i = 0; i < n - 1; i++) {            if (s.charAt(i) == s.charAt(i + 1)) {                isPalindrome[i][i + 1] = true;                start = i;                maxLen = 2;            }        }         // Check substrings of length 3 or more        for (int len = 3; len <= n; len++) {            for (int i = 0; i <= n - len; i++) {                int j = i + len - 1;                if (isPalindrome[i + 1][j - 1] && s.charAt(i) == s.charAt(j)) {                    isPalindrome[i][j] = true;                    start = i;                    maxLen = len;                }            }        }         return s.substring(start, start + maxLen);    } // code ends     // code of palindrome starts here, partioning which is used to get all sets in    // the string which are palindrome    public List<List<String>> partition(String s) {        List<List<String>> list = new ArrayList<>();        backtrack(list, new ArrayList<>(), s, 0);        return list;    }     public void backtrack(List<List<String>> list, List<String> tempList, String s, int start) {        if (start == s.length())            list.add(new ArrayList<>(tempList));        else {            for (int i = start; i < s.length(); i++) {                if (isPalindrome(s, start, i)) {                    tempList.add(s.substring(start, i + 1));                    backtrack(list, tempList, s, i + 1);                    tempList.remove(tempList.size() - 1);                }            }        }    }     public boolean isPalindrome(String s, int low, int high) {        while (low < high)            if (s.charAt(low++) != s.charAt(high--))                return false;        return true;    }    // code ends here..     // code of combinational sum (basic)--> where we can use duplicate elements    // used to find the set of all elements in the given arr whose sum equals to    // given target..    public List<List<Integer>> combinationSum(int[] nums, int target) {        List<List<Integer>> list = new ArrayList<>();        Arrays.sort(nums);        backtrack2(list, new ArrayList<>(), nums, target, 0);        return list;    }     public void backtrack2(List<List<Integer>> list, List<Integer> tempList, int[] nums, int remain, int start) {        if (remain < 0)            return;        else if (remain == 0)            list.add(new ArrayList<>(tempList));        else {            for (int i = start; i < nums.length; i++) {                tempList.add(nums[i]);                backtrack2(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements                tempList.remove(tempList.size() - 1);            }        }    } // code ends here..     // code of combinatinal sum (advanced) where we cant take duplicate elements..    // starts here..    public List<List<Integer>> combinationSum2(int[] nums, int target) {        List<List<Integer>> list = new ArrayList<>();        Arrays.sort(nums);        backtrack3(list, new ArrayList<>(), nums, target, 0);        return list;     }     public void backtrack3(List<List<Integer>> list, List<Integer> tempList, int[] nums, int remain, int start) {        if (remain < 0)            return;        else if (remain == 0)            list.add(new ArrayList<>(tempList));        else {            for (int i = start; i < nums.length; i++) {                if (i > start && nums[i] == nums[i - 1])                    continue; // skip duplicates                tempList.add(nums[i]);                backtrack3(list, tempList, nums, remain - nums[i], i + 1);                tempList.remove(tempList.size() - 1);            }        }    } // code ends here..      // code of basic permutations cant take duplicates....starts here     public List<List<Integer>> permute(int[] nums) {        List<List<Integer>> list = new ArrayList<>();        // Arrays.sort(nums); // not necessary        backtrack4(list, new ArrayList<>(), nums);        return list;    }     public void backtrack4(List<List<Integer>> list, List<Integer> tempList, int[] nums) {        if (tempList.size() == nums.length) {            list.add(new ArrayList<>(tempList));        } else {            for (int i = 0; i < nums.length; i++) {                if (tempList.contains(nums[i]))                    continue; // element already exists, skip                tempList.add(nums[i]);                backtrack4(list, tempList, nums);                tempList.remove(tempList.size() - 1);            }        }    } // code ends here..     static long gcd(long a, long b) {        if (b == 0)            return a;        return gcd(b, a % b);    }     int pieces(int n, int a, int b, int c, int steps) {        if (n == 0) {            return steps;        } else if (n <= 0) {         }        return steps;    }     boolean makez(int arr[]) {        for (int i = 0; i < arr.length; i++) {            if (arr[i] != 0) {                return false;            }        }        return true;    }     void solve() {        int len = sc.nextInt();        String arr[] = new String[len];        int arr2[] = new int[len];        Map<String, Integer> map = new HashMap<>();        Map<String, Integer> map2 = new HashMap<>();        for (int i = 0; i < len; i++) {            arr[i] = sc.next();            arr2[i] = sc.nextInt();            map.put(arr[i], map.getOrDefault(arr[i], 0) + arr2[i]);        }        int ans = 0;        for (int i = 0; i < len; i++) {            ans = Math.max(ans, map.get(arr[i]));        }        for (int i = 0; i < len; i++) {            map2.put(arr[i], map2.getOrDefault(arr[i], 0) + arr2[i]);            if (map.get(arr[i]) == ans && map2.get(arr[i]) >= ans) {                out.println(arr[i]);                break;            }        }     }}